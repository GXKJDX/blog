<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://github.com/GXKJDX/blog/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/blog/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/blog/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/blog/css/style.css">

  
    
<link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/blog/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/GXKJDX/blog"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-JavaScript-内置方法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/2025/04/11/JavaScript-%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2025-04-11T14:33:31.524Z" itemprop="datePublished">2025-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="1-JSON"><a href="#1-JSON" class="headerlink" title="1. JSON"></a>1. JSON</h3><h4 id="1-JSON-parse"><a href="#1-JSON-parse" class="headerlink" title="1.JSON.parse"></a>1.JSON.parse</h4><p>将 JSON 字符串解析为 JavaScript 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jsonString = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:25&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonString);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// 输出: Alice</span></span><br></pre></td></tr></table></figure>

<h4 id="2-JSON-stringify"><a href="#2-JSON-stringify" class="headerlink" title="2. JSON.stringify()"></a>2. JSON.stringify()</h4><p>将 JavaScript 对象转换为 JSON 字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;Bob&quot;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> jsonString = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jsonString); <span class="comment">// 输出: &#123;&quot;name&quot;:&quot;Bob&quot;,&quot;age&quot;:30&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-JSON-stringify-obj-replacer-space"><a href="#3-JSON-stringify-obj-replacer-space" class="headerlink" title="3. JSON.stringify(obj, replacer, space)"></a>3. JSON.stringify(obj, replacer, space)</h4><p><code>replacer</code>：用于过滤或转换属性<br> <code>space</code>：格式化缩进，常用于打印美观的 JSON 字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;Charlie&quot;</span>, <span class="attr">age</span>: <span class="number">28</span>, <span class="attr">password</span>: <span class="string">&quot;secret&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤 password 字段</span></span><br><span class="line"><span class="keyword">const</span> json1 = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj, [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(json1); <span class="comment">// &#123;&quot;name&quot;:&quot;Charlie&quot;,&quot;age&quot;:28&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缩进格式化（常用于开发调试）</span></span><br><span class="line"><span class="keyword">const</span> prettyJson = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj, <span class="literal">null</span>, <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(prettyJson);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &quot;name&quot;: &quot;Charlie&quot;,</span></span><br><span class="line"><span class="comment">  &quot;age&quot;: 28,</span></span><br><span class="line"><span class="comment">  &quot;password&quot;: &quot;secret&quot;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="4-JSON-parse-（try…catch）"><a href="#4-JSON-parse-（try…catch）" class="headerlink" title="4. JSON.parse() （try…catch）"></a>4. JSON.parse() （try…catch）</h4><p>解析非法 JSON 字符串时会抛出错误，建议包裹在 try…catch 中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> badJson = <span class="string">&#x27;&#123; name: &quot;Alice&quot; &#125;&#x27;</span>; <span class="comment">// 非法 JSON（属性名未加双引号）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> obj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(badJson);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;解析失败:&quot;</span>, err.<span class="property">message</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>JSON 中 key 和 string 值都必须是双引号（”），不能用单引号</li>
<li>undefined、函数、Symbol 类型无法被序列化</li>
</ul>
<h3 id="2-String"><a href="#2-String" class="headerlink" title="2.String"></a>2.String</h3><h4 id="1-String-prototype-split"><a href="#1-String-prototype-split" class="headerlink" title="1. String.prototype.split"></a>1. String.prototype.split</h4><p>将字符串按指定分隔符拆分为数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;apple,banana,orange&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> fruits = str.<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruits); <span class="comment">// 输出: [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;]</span></span><br></pre></td></tr></table></figure>

<h4 id="2-String-prototype-replace"><a href="#2-String-prototype-replace" class="headerlink" title="2. String.prototype.replace"></a>2. String.prototype.replace</h4><p>替换字符串中的部分内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> newStr = str.<span class="title function_">replace</span>(<span class="string">&quot;World&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newStr); <span class="comment">// 输出: Hello, JavaScript!</span></span><br></pre></td></tr></table></figure>

<h4 id="3-String-prototype-trim"><a href="#3-String-prototype-trim" class="headerlink" title="3. String.prototype.trim"></a>3. String.prototype.trim</h4><p>去除字符串两端的空白字符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;   Hello, World!   &quot;</span>;</span><br><span class="line"><span class="keyword">const</span> trimmedStr = str.<span class="title function_">trim</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(trimmedStr); <span class="comment">// 输出: &quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-Array"><a href="#3-Array" class="headerlink" title="3.Array"></a>3.Array</h3><h4 id="1-Array-prototype-map"><a href="#1-Array-prototype-map" class="headerlink" title="1. Array.prototype.map"></a>1. Array.prototype.map</h4><p>对数组中的每个元素执行回调函数，并返回一个新数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> doubled = numbers.<span class="title function_">map</span>(<span class="function"><span class="params">num</span> =&gt;</span> num * <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(doubled); <span class="comment">// 输出: [2, 4, 6]</span></span><br></pre></td></tr></table></figure>

<h4 id="2-Array-prototype-filter"><a href="#2-Array-prototype-filter" class="headerlink" title="2. Array.prototype.filter"></a>2. Array.prototype.filter</h4><p>根据条件过滤数组，返回满足条件的新数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> evens = numbers.<span class="title function_">filter</span>(<span class="function"><span class="params">num</span> =&gt;</span> num % <span class="number">2</span> === <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(evens); <span class="comment">// 输出: [2, 4]</span></span><br></pre></td></tr></table></figure>

<h4 id="3-Array-prototype-reduce"><a href="#3-Array-prototype-reduce" class="headerlink" title="3. Array.prototype.reduce"></a>3. Array.prototype.reduce</h4><p>将数组中的元素累积为一个值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> sum = numbers.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, num</span>) =&gt;</span> acc + num, <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum); <span class="comment">// 输出: 10</span></span><br></pre></td></tr></table></figure>

<h4 id="4-Array-prototype-forEach"><a href="#4-Array-prototype-forEach" class="headerlink" title="4. Array.prototype.forEach"></a>4. Array.prototype.forEach</h4><p>遍历数组，对每个元素执行回调函数（无返回值）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">numbers.<span class="title function_">forEach</span>(<span class="function"><span class="params">num</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(num)); <span class="comment">// 依次输出: 1, 2, 3</span></span><br></pre></td></tr></table></figure>

<h4 id="5-Array-prototype-includes"><a href="#5-Array-prototype-includes" class="headerlink" title="5. Array.prototype.includes"></a>5. Array.prototype.includes</h4><p>检查数组是否包含某个值，返回布尔值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numbers.<span class="title function_">includes</span>(<span class="number">2</span>)); <span class="comment">// 输出: true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numbers.<span class="title function_">includes</span>(<span class="number">4</span>)); <span class="comment">// 输出: false</span></span><br></pre></td></tr></table></figure>

<h4 id="6-Array-prototype-find"><a href="#6-Array-prototype-find" class="headerlink" title="6. Array.prototype.find"></a>6. Array.prototype.find</h4><p>查找数组中满足条件的第一个元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> found = numbers.<span class="title function_">find</span>(<span class="function"><span class="params">num</span> =&gt;</span> num &gt; <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(found); <span class="comment">// 输出: 3</span></span><br></pre></td></tr></table></figure>

<h4 id="7-Array-prototype-some"><a href="#7-Array-prototype-some" class="headerlink" title="7. Array.prototype.some"></a>7. Array.prototype.some</h4><p>检查数组中是否有至少一个元素满足条件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> hasEven = numbers.<span class="title function_">some</span>(<span class="function"><span class="params">num</span> =&gt;</span> num % <span class="number">2</span> === <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hasEven); <span class="comment">// 输出: true</span></span><br></pre></td></tr></table></figure>

<h4 id="8-Array-prototype-every"><a href="#8-Array-prototype-every" class="headerlink" title="8. Array.prototype.every"></a>8. Array.prototype.every</h4><p>检查数组中的所有元素是否都满足条件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">const</span> allEven = numbers.<span class="title function_">every</span>(<span class="function"><span class="params">num</span> =&gt;</span> num % <span class="number">2</span> === <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(allEven); <span class="comment">// 输出: true</span></span><br></pre></td></tr></table></figure>

<h3 id="3-Object"><a href="#3-Object" class="headerlink" title="3. Object"></a>3. Object</h3><h4 id="1-Object-keys"><a href="#1-Object-keys" class="headerlink" title="1. Object.keys"></a>1. Object.keys</h4><p>获取对象的所有键，返回一个数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(keys); <span class="comment">// 输出: [&quot;name&quot;, &quot;age&quot;]</span></span><br></pre></td></tr></table></figure>

<h4 id="2-Object-values"><a href="#2-Object-values" class="headerlink" title="2. Object.values"></a>2. Object.values</h4><p>获取对象的所有值，返回一个数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> values = <span class="title class_">Object</span>.<span class="title function_">values</span>(obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(values); <span class="comment">// 输出: [&quot;Alice&quot;, 25]</span></span><br></pre></td></tr></table></figure>

<h4 id="3-Object-entries"><a href="#3-Object-entries" class="headerlink" title="3. Object.entries"></a>3. Object.entries</h4><p>获取对象的键值对，返回一个二维数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> entries = <span class="title class_">Object</span>.<span class="title function_">entries</span>(obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(entries); <span class="comment">// 输出: [[&quot;name&quot;, &quot;Alice&quot;], [&quot;age&quot;, 25]]</span></span><br></pre></td></tr></table></figure>

<h4 id="4-Object-assign"><a href="#4-Object-assign" class="headerlink" title="4. Object.assign"></a>4. Object.assign</h4><p>将一个或多个对象的属性合并到目标对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> merged = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj1, obj2);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(merged); <span class="comment">// 输出: &#123; a: 1, b: 2 &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-Function-prototype-bind"><a href="#4-Function-prototype-bind" class="headerlink" title="4. Function.prototype.bind"></a>4. Function.prototype.bind</h3><h4 id="1-Function-prototype-bind"><a href="#1-Function-prototype-bind" class="headerlink" title="1. Function.prototype.bind"></a>1. Function.prototype.bind</h4><p>创建一个新函数，绑定指定的 <code>this</code> 值和参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">  <span class="attr">greet</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> greet = person.<span class="property">greet</span>.<span class="title function_">bind</span>(person);</span><br><span class="line"><span class="title function_">greet</span>(); <span class="comment">// 输出: Hello, Alice</span></span><br></pre></td></tr></table></figure>

<h3 id="5-Promise"><a href="#5-Promise" class="headerlink" title="5. Promise"></a>5. Promise</h3><p>用于处理异步操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;Success!&quot;</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result)); <span class="comment">// 1秒后输出: Success!</span></span><br></pre></td></tr></table></figure>

<h3 id="6-async-await"><a href="#6-async-await" class="headerlink" title="6. async&#x2F;await"></a>6. async&#x2F;await</h3><p>简化异步操作的语法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;https://api.example.com/data&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetchData</span>();</span><br></pre></td></tr></table></figure>

<h3 id="7-Set"><a href="#7-Set" class="headerlink" title="7. Set"></a>7. Set</h3><p>用于存储唯一值的集合。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> uniqueNumbers = [...<span class="keyword">new</span> <span class="title class_">Set</span>(numbers)];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uniqueNumbers); <span class="comment">// 输出: [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<h3 id="8-Map"><a href="#8-Map" class="headerlink" title="8. Map"></a>8. Map</h3><p>用于存储键值对，键可以是任意类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&quot;age&quot;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">get</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// 输出: Alice</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="property">size</span>); <span class="comment">// 输出: 2</span></span><br></pre></td></tr></table></figure>

<h3 id="9-Date"><a href="#9-Date" class="headerlink" title="9. Date"></a>9. Date</h3><p>用于处理日期和时间。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(now.<span class="title function_">toISOString</span>()); <span class="comment">// 输出当前时间的 ISO 格式字符串</span></span><br></pre></td></tr></table></figure>

<h3 id="10-Math"><a href="#10-Math" class="headerlink" title="10. Math"></a>10. Math</h3><p>提供数学运算的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 输出: 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()); <span class="comment">// 输出: 0到1之间的随机数</span></span><br></pre></td></tr></table></figure>

<h3 id="11-RegExp"><a href="#11-RegExp" class="headerlink" title="11. RegExp"></a>11. RegExp</h3><p>用于处理正则表达式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/hello/i</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(regex.<span class="title function_">test</span>(<span class="string">&quot;Hello, World!&quot;</span>)); <span class="comment">// 输出: true</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>JavaScript 提供了丰富的内置方法，涵盖了数据处理、异步操作、集合操作等多个方面。掌握这些方法可以极大地提高开发效率！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/GXKJDX/blog/2025/04/11/JavaScript-%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/" data-id="cm9cw35xe0000s8u4fyn7d989" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java基础-集合" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/2025/04/11/Java%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88/" class="article-date">
  <time class="dt-published" datetime="2025-04-11T14:32:50.000Z" itemprop="datePublished">2025-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/2025/04/11/Java%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88/">五、Java基础-集合</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://qinyunjian-1316017204.cos.ap-guangzhou.myqcloud.com/images/typora/collection.png" alt="collection"></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><strong>Java 集合框架</strong>可以分为两条大的支线：</p>
<p>①、<code>Collection</code>，主要由 <code>List</code>、<code>Set</code>、<code>Queue</code> 组成：</p>
<ul>
<li><code>List</code> 代表有序、可重复的集合，典型代表就是封装了动态数组的 <code>ArrayList</code>和封装了链表的 <code>LinkedList</code>；</li>
<li><code>Set</code> 代表无序、不可重复的集合，典型代表就是 <code>HashSet</code> 和 <code>TreeSet</code>；</li>
<li><code>Queue</code> 代表队列，典型代表就是双端队列 <code>ArrayDeque</code>，以及优先级队列 <code>PriorityQueue</code></li>
</ul>
<p>②、<code>Map</code>，代表键值对的集合，典型代表就是 <code>HashMap</code></p>
<h3 id="1、List"><a href="#1、List" class="headerlink" title="1、List"></a>1、List</h3><p><code>List</code> 的特点是存取有序，可以存放重复的元素，可以用下标对元素进行操作。</p>
<h4 id="1-1-ArrayList"><a href="#1-1-ArrayList" class="headerlink" title="1.1 ArrayList"></a>1.1 ArrayList</h4><p> <code>ArrayList</code> 的增删改查。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个集合</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">list.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;cherry&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历集合 for 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历集合 for each</span></span><br><span class="line"><span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">list.remove(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 遍历集合</span></span><br><span class="line"><span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改元素</span></span><br><span class="line">list.set(<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line"><span class="comment">// 遍历集合</span></span><br><span class="line"><span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单介绍一下 <code>ArrayList</code> 的特征</p>
<ul>
<li><code>ArrayList</code> 是由数组实现的，支持随机存取，也就是可以通过下标直接存取元素；</li>
<li>从尾部插入和删除元素会比较快捷，从中间插入和删除元素会比较低效，因为涉及到数组元素的复制和移动；</li>
<li>如果内部数组的容量不足时会自动扩容，因此当元素非常庞大的时候，效率会比较低。</li>
</ul>
<h4 id="1-2、LinkedList"><a href="#1-2、LinkedList" class="headerlink" title="1.2、LinkedList"></a>1.2、LinkedList</h4><p> <code>LinkedList</code> 的增删改查，和 <code>ArrayList</code> 几乎没什么差别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个集合</span></span><br><span class="line">LinkedList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">list.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;cherry&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历集合 for 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历集合 for each</span></span><br><span class="line"><span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">list.remove(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 遍历集合</span></span><br><span class="line"><span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改元素</span></span><br><span class="line">list.set(<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line"><span class="comment">// 遍历集合</span></span><br><span class="line"><span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，<code>LinkedList</code> 和 <code>ArrayList</code> 仍然有较大的不同</p>
<ul>
<li><code>LinkedList</code> 是由双向链表实现的，不支持随机存取，只能从一端开始遍历，直到找到需要的元素后返回；</li>
<li>任意位置插入和删除元素都很方便，因为只需要改变前一个节点和后一个节点的引用即可，不像 <code>ArrayList</code> 那样需要复制和移动数组元素；</li>
<li>因为每个元素都存储了前一个和后一个节点的引用，所以相对来说，占用的内存空间会比 <code>ArrayList</code> 多一些。</li>
</ul>
<h4 id="1-3-Vector-和-Stack"><a href="#1-3-Vector-和-Stack" class="headerlink" title="1.3 Vector 和 Stack"></a>1.3 Vector 和 Stack</h4><p><code>List</code> 的实现类还有一个 <code>Vector</code>，是一个元老级的类，比 <code>ArrayList</code> 出现得更早。<code>ArrayList</code> 和 <code>Vector</code> 非常相似，只不过 <code>Vector</code> 是线程安全的，像 <code>get</code>、<code>set</code>、<code>add</code> 这些方法都加了 <code>synchronized</code> 关键字，就导致执行效率会比较低，所以现在已经很少用了。</p>
<p><code>add</code> 方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种加了同步方法的类，注定会被淘汰掉，就像<code>StringBuilder</code> 取代 <code>StringBuffer</code>那样。JDK 源码也说了：</p>
<blockquote>
<p>如果不需要线程安全，建议使用 ArrayList 代替 Vector。</p>
</blockquote>
<h3 id="2、Set"><a href="#2、Set" class="headerlink" title="2、Set"></a>2、Set</h3><p><code>Set</code> 的特点是存取无序，不可以存放重复的元素，不可以用下标对元素进行操作，和 <code>List</code> 有很多不同。</p>
<h4 id="2-1-HashSet"><a href="#2-1-HashSet" class="headerlink" title="2.1 HashSet"></a>2.1 HashSet</h4><p><code>HashSet</code> 其实是由 <code>HashMap</code> 实现的，只不过值由一个固定的 <code>Object</code> 对象填充，而键用于操作，<code>HashSet</code>源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际开发中，<code>HashSet</code> 并不常用，比如，如果我们需要按照顺序存储一组元素，那么 <code>ArrayList</code> 和 <code>LinkedList</code> 可能更适合；如果我们需要存储键值对并根据键进行查找，那么 <code>HashMap</code> 可能更适合。</p>
<p>增删改查代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的HashSet</span></span><br><span class="line">HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">set.add(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;cherry&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出HashSet的元素个数</span></span><br><span class="line">System.out.println(<span class="string">&quot;HashSet size: &quot;</span> + set.size()); <span class="comment">// output: 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断元素是否存在于HashSet中</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">contains2</span> <span class="operator">=</span> set.contains(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Does set contain &#x27;apple&#x27;? &quot;</span> + contains2); <span class="comment">// output: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">remove2</span> <span class="operator">=</span> set.remove(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Removed &#x27;apple&#x27;? &quot;</span> + remove2); <span class="comment">// output: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改元素，需要先删除后添加</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">removeChenmo</span> <span class="operator">=</span> set.remove(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">addBuChenmo</span> <span class="operator">=</span> set.add(<span class="string">&quot;不banana&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Modified set? &quot;</span> + (removeChenmo &amp;&amp; addBuChenmo)); <span class="comment">// output: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出修改后的HashSet</span></span><br><span class="line">System.out.println(<span class="string">&quot;HashSet after modification: &quot;</span> + set); <span class="comment">// output: [cherry, 不banana]</span></span><br></pre></td></tr></table></figure>

<p><code>HashSet</code> 主要用于去重，比如，我们需要统计一篇文章中有多少个不重复的单词，就可以使用 <code>HashSet</code> 来实现。</p>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 HashSet 对象</span></span><br><span class="line">HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">set.add(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;cherry&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 HashSet 的元素个数</span></span><br><span class="line">System.out.println(<span class="string">&quot;HashSet size: &quot;</span> + set.size()); <span class="comment">// output: 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 HashSet</span></span><br><span class="line"><span class="keyword">for</span> (String s : set) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的例子可以看得出，<code>HashSet</code> 会自动去重，因为它是用 <code>HashMap</code> 实现的，<code>HashMap</code>的键是唯一的（哈希值），相同键的值会覆盖掉原来的值，于是第二次 <code>set.add(&quot;banana&quot;)</code> 的时候就覆盖了第一次的 <code>set.add(&quot;banana&quot;)</code>。</p>
<p>我在的时候用到了 <code>HashSet</code>，大家可以通过链接去查看一下。</p>
<h4 id="2-2-LinkedHashSet"><a href="#2-2-LinkedHashSet" class="headerlink" title="2.2 LinkedHashSet"></a>2.2 LinkedHashSet</h4><p><code>LinkedHashSet</code> 虽然继承自 <code>HashSet</code>，其实是由 <code>LinkedHashMap</code>实现的。</p>
<p><code>LinkedHashSet</code> 的无参构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="number">16</span>, <span class="number">.75f</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的意思是它将调用父类的 <code>HashSet</code> 的一个有参构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashSet(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p> <code>LinkedHashSet</code> 的增删改查示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">set.add(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;cherry&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">set.remove(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改元素</span></span><br><span class="line">set.remove(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;banana的力量&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找元素</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">has3</span> <span class="operator">=</span> set.contains(<span class="string">&quot;cherry&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;set包含cherry吗？&quot;</span> + has3);</span><br></pre></td></tr></table></figure>

<p>在以上代码中，我们首先创建了一个 <code>LinkedHashSet</code> 对象，然后使用 <code>add</code> 方法依次添加了三个元素：<code>banana</code>、<code>apple</code>和<code>cherry</code>。接着，我们使用 <code>remove</code> 方法删除了<code>apple</code>这个元素，并使用 <code>remove</code> 和 <code>add</code> 方法修改了<code>banana</code>这个元素。最后，我们使用 <code>contains</code> 方法查找了<code>cherry</code>这个元素是否存在于 <code>set</code> 中，并打印了结果。<code>LinkedHashSet</code> 是一种基于哈希表实现的 <code>Set</code> 接口，它继承自 <code>HashSet</code>，并且使用链表维护了元素的插入顺序。因此，它既具有 <code>HashSet</code> 的快速查找、插入和删除操作的优点，又可以维护元素的插入顺序。</p>
<h4 id="2-3-TreeSet"><a href="#2-3-TreeSet" class="headerlink" title="2.3 TreeSet"></a>2.3 TreeSet</h4><p>是的，与 <code>TreeMap</code> 相似，<code>TreeSet</code> 是一种基于红黑树实现的有序集合，它实现了 <code>SortedSet</code> 接口，可以自动对集合中的元素进行排序。按照键的自然顺序或指定的比较器顺序进行排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 TreeSet 对象</span></span><br><span class="line">TreeSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">set.add(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;cherry&quot;</span>);</span><br><span class="line">System.out.println(set); <span class="comment">// 输出 [banana, apple, cherry]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">set.remove(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">System.out.println(set); <span class="comment">// 输出 [banana, cherry]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改元素：TreeSet 中的元素不支持直接修改，需要先删除再添加</span></span><br><span class="line">set.remove(<span class="string">&quot;cherry&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;qyj&quot;</span>);</span><br><span class="line">System.out.println(set); <span class="comment">// 输出 [banana, qyj]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找元素</span></span><br><span class="line">System.out.println(set.contains(<span class="string">&quot;banana&quot;</span>)); <span class="comment">// 输出 true</span></span><br><span class="line">System.out.println(set.contains(<span class="string">&quot;apple&quot;</span>)); <span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>TreeSet</code> 不允许插入 <code>null</code> 元素，否则会抛出 <code>NullPointerException</code> 异常。</p>
<h3 id="3、Queue"><a href="#3、Queue" class="headerlink" title="3、Queue"></a>3、Queue</h3><p><code>Queue</code>，也就是队列，通常遵循先进先出（<code>FIFO</code>）的原则，新元素插入到队列的尾部，访问元素返回队列的头部。</p>
<h4 id="3-1-ArrayDeque"><a href="#3-1-ArrayDeque" class="headerlink" title="3.1 ArrayDeque"></a>3.1 ArrayDeque</h4><p>从名字上可以看得出，<code>ArrayDeque</code> 是一个基于数组实现的双端队列，为了满足可以同时在数组两端插入或删除元素的需求，数组必须是循环的，也就是说数组的任何一点都可以被看作是起点或者终点。</p>
<p>这是一个包含了 4 个元素的双端队列，和一个包含了 5 个元素的双端队列。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/gailan-02.png" alt="img"></p>
<p><code>head</code> 指向队首的第一个有效的元素，<code>tail</code> 指向队尾第一个可以插入元素的空位，因为是循环数组，所以 <code>head</code> 不一定从是从 0 开始，<code>tail</code> 也不一定总是比 <code>head</code> 大。<code>ArrayDeque</code> 的增删改查示例：。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个ArrayDeque</span></span><br><span class="line">ArrayDeque&lt;String&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">deque.add(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">deque.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">deque.add(<span class="string">&quot;cherry&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">deque.remove(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改元素</span></span><br><span class="line">deque.remove(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">deque.add(<span class="string">&quot;banana的力量&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找元素</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">has3</span> <span class="operator">=</span> deque.contains(<span class="string">&quot;cherry&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;deque包含cherry吗？&quot;</span> + has3);</span><br></pre></td></tr></table></figure>

<h4 id="3-2-LinkedList"><a href="#3-2-LinkedList" class="headerlink" title="3.2 LinkedList"></a>3.2 LinkedList</h4><p><code>LinkedList</code> 一般应该归在 <code>List</code> 下，只不过，它也实现了 <code>Deque</code> 接口，可以作为队列来使用。等于说，<code>LinkedList</code> 同时实现了 <code>Stack</code>、<code>Queue</code>、<code>PriorityQueue</code> 的所有功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>换句话说，<code>LinkedList</code> 和 <code>ArrayDeque</code> 都是 Java 集合框架中的双向队列（deque），它们都支持在队列的两端进行元素的插入和删除操作。不过，<code>LinkedList</code> 和 <code>ArrayDeque</code> 在实现上有一些不同：</p>
<ul>
<li>底层实现方式不同：<code>LinkedList</code> 是基于链表实现的，而 <code>ArrayDeque</code> 是基于数组实现的。</li>
<li>随机访问的效率不同：由于底层实现方式的不同，<code>LinkedList</code> 对于随机访问的效率较低，时间复杂度为 O(n)，而 <code>ArrayDeque</code> 可以通过下标随机访问元素，时间复杂度为 O(1)。</li>
<li>迭代器的效率不同：<code>LinkedList</code> 对于迭代器的效率比较低，因为需要通过链表进行遍历，时间复杂度为 O(n)，而 <code>ArrayDeque</code> 的迭代器效率比较高，因为可以直接访问数组中的元素，时间复杂度为 O(1)。</li>
<li>内存占用不同：由于 <code>LinkedList</code> 是基于链表实现的，它在存储元素时需要额外的空间来存储链表节点，因此内存占用相对较高，而 <code>ArrayDeque</code> 是基于数组实现的，内存占用相对较低。</li>
</ul>
<p>因此，在选择使用 <code>LinkedList</code> 还是 <code>ArrayDeque</code> 时，需要根据具体的业务场景和需求来选择。如果需要在双向队列的两端进行频繁的插入和删除操作，并且需要随机访问元素，可以考虑使用 <code>ArrayDeque</code>；如果需要在队列中间进行频繁的插入和删除操作，可以考虑使用 <code>LinkedList</code>。</p>
<p>来一段 <code>LinkedList</code> 作为队列时候的增删改查吧，注意和它作为 <code>List</code> 的时候有很大的不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 LinkedList 对象</span></span><br><span class="line">LinkedList&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">queue.offer(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">queue.offer(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">queue.offer(<span class="string">&quot;cherry&quot;</span>);</span><br><span class="line">System.out.println(queue); <span class="comment">// 输出 [banana, apple, cherry]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">queue.poll();</span><br><span class="line">System.out.println(queue); <span class="comment">// 输出 [apple, cherry]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改元素：LinkedList 中的元素不支持直接修改，需要先删除再添加</span></span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">queue.offer(<span class="string">&quot;王大二&quot;</span>);</span><br><span class="line">System.out.println(queue); <span class="comment">// 输出 [cherry, 王大二]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找元素：LinkedList 中的元素可以使用 get() 方法进行查找</span></span><br><span class="line">System.out.println(queue.get(<span class="number">0</span>)); <span class="comment">// 输出 cherry</span></span><br><span class="line">System.out.println(queue.contains(<span class="string">&quot;banana&quot;</span>)); <span class="comment">// 输出 false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找元素：使用迭代器的方式查找cherry</span></span><br><span class="line"><span class="comment">// 使用迭代器依次遍历元素并查找</span></span><br><span class="line">Iterator&lt;String&gt; iterator = queue.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (element.equals(<span class="string">&quot;cherry&quot;</span>)) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;找到了：&quot;</span> + element);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用 <code>LinkedList</code> 作为队列时，可以使用 offer() 方法将元素添加到队列的末尾，使用 poll() 方法从队列的头部删除元素。另外，由于 <code>LinkedList</code> 是链表结构，不支持随机访问元素，因此不能使用下标访问元素，需要使用迭代器或者 poll() 方法依次遍历元素。</p>
<h4 id="3-3-PriorityQueue"><a href="#3-3-PriorityQueue" class="headerlink" title="3.3 PriorityQueue"></a>3.3 PriorityQueue</h4><p><code>PriorityQueue</code> 是一种优先级队列，它的出队顺序与元素的优先级有关，执行 <code>remove</code> 或者 <code>poll</code> 方法，返回的总是优先级最高的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 PriorityQueue 对象</span></span><br><span class="line">PriorityQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">queue.offer(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">queue.offer(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">queue.offer(<span class="string">&quot;cherry&quot;</span>);</span><br><span class="line">System.out.println(queue); <span class="comment">// 输出 [banana, apple, cherry]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">queue.poll();</span><br><span class="line">System.out.println(queue); <span class="comment">// 输出 [apple, cherry]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改元素：PriorityQueue 不支持直接修改元素，需要先删除再添加</span></span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">queue.offer(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">System.out.println(queue); <span class="comment">// 输出 [张三, cherry]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找元素：PriorityQueue 不支持随机访问元素，只能访问队首元素</span></span><br><span class="line">System.out.println(queue.peek()); <span class="comment">// 输出 张三</span></span><br><span class="line">System.out.println(queue.contains(<span class="string">&quot;cherry&quot;</span>)); <span class="comment">// 输出 true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 for 循环的方式查找cherry</span></span><br><span class="line"><span class="keyword">for</span> (String element : queue) &#123;</span><br><span class="line">    <span class="keyword">if</span> (element.equals(<span class="string">&quot;cherry&quot;</span>)) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;找到了：&quot;</span> + element);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要想有优先级，元素就需要实现 <code>Comparable</code> 接口或者 <code>Comparator</code> 接口。</p>
<p>这里先来一段通过实现 <code>Comparator</code> 接口按照年龄姓名排序的优先级队列吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> chineseScore;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mathScore;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> chineseScore, <span class="type">int</span> mathScore)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.chineseScore = chineseScore;</span><br><span class="line">        <span class="built_in">this</span>.mathScore = mathScore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getChineseScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> chineseScore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMathScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mathScore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, 总成绩=&quot;</span> + (chineseScore + mathScore) +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StudentComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Student&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student s1, Student s2)</span> &#123;</span><br><span class="line">        <span class="comment">// 比较总成绩</span></span><br><span class="line">        <span class="keyword">return</span> Integer.compare(s2.getChineseScore() + s2.getMathScore(),</span><br><span class="line">                s1.getChineseScore() + s1.getMathScore());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityQueueComparatorExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个按照总成绩排序的优先级队列</span></span><br><span class="line">        PriorityQueue&lt;Student&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">StudentComparator</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;apple&quot;</span>, <span class="number">80</span>, <span class="number">90</span>));</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;cherry&quot;</span>, <span class="number">95</span>, <span class="number">95</span>));</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;qinyunjian&quot;</span>, <span class="number">90</span>, <span class="number">95</span>));</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;banana&quot;</span>, <span class="number">90</span>, <span class="number">80</span>));</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            System.out.print(queue.poll() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Student</code> 是一个学生对象，包含姓名、语文成绩和数学成绩。</p>
<p><code>StudentComparator</code> 实现了 <code>Comparator</code> 接口，对总成绩做了一个排序。</p>
<p><code>PriorityQueue</code> 是一个优先级队列，参数为 <code>StudentComparator</code>，然后我们添加了 4 个学生对象进去。</p>
<p>来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Student&#123;name=&#x27;apple&#x27;, 总成绩=170&#125;]</span><br><span class="line">[Student&#123;name=&#x27;cherry&#x27;, 总成绩=190&#125;, Student&#123;name=&#x27;apple&#x27;, 总成绩=170&#125;]</span><br><span class="line">[Student&#123;name=&#x27;cherry&#x27;, 总成绩=190&#125;, Student&#123;name=&#x27;apple&#x27;, 总成绩=170&#125;, Student&#123;name=&#x27;qinyunjian&#x27;, 总成绩=185&#125;]</span><br><span class="line">Student&#123;name=&#x27;cherry&#x27;, 总成绩=190&#125; Student&#123;name=&#x27;qinyunjian&#x27;, 总成绩=185&#125; Student&#123;name=&#x27;banana&#x27;, 总成绩=170&#125; Student&#123;name=&#x27;apple&#x27;, 总成绩=170&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用 <code>offer</code> 方法添加元素，最后用 <code>while</code> 循环遍历元素（通过 <code>poll</code> 方法取出元素），从结果可以看得出，<code>PriorityQueue</code>按照学生的总成绩由高到低进行了排序。</p>
<h3 id="4、Map"><a href="#4、Map" class="headerlink" title="4、Map"></a>4、Map</h3><p><code>Map</code> 保存的是键值对，键要求保持唯一性，值可以重复。</p>
<h4 id="4-1-HashMap"><a href="#4-1-HashMap" class="headerlink" title="4.1 HashMap"></a>4.1 HashMap</h4><p><code>HashMap</code> 实现了 <code>Map</code> 接口，可以根据键快速地查找对应的值——通过哈希函数将键映射到哈希表中的一个索引位置，从而实现快速访问。</p>
<p>这里先大致了解一下 <code>HashMap</code> 的特点：</p>
<ul>
<li><code>HashMap</code> 中的键和值都可以为 <code>null</code>。如果键为 <code>null</code>，则将该键映射到哈希表的第一个位置。</li>
<li>可以使用迭代器或者 <code>forEach</code> 方法遍历 <code>HashMap</code> 中的键值对。</li>
<li><code>HashMap</code> 有一个初始容量和一个负载因子。初始容量是指哈希表的初始大小，负载因子是指哈希表在扩容之前可以存储的键值对数量与哈希表大小的比率。默认的初始容量是 16，负载因子是 0.75。</li>
</ul>
<p>来个简单的增删改查吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 HashMap 对象</span></span><br><span class="line">HashMap&lt;String, String&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加键值对</span></span><br><span class="line">hashMap.put(<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;cherry&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定键的值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">value1</span> <span class="operator">=</span> hashMap.get(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;banana对应的值为：&quot;</span> + value1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改键对应的值</span></span><br><span class="line">hashMap.put(<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;chenmo&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">value2</span> <span class="operator">=</span> hashMap.get(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;修改后banana对应的值为：&quot;</span> + value2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定键的键值对</span></span><br><span class="line">hashMap.remove(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 HashMap</span></span><br><span class="line"><span class="keyword">for</span> (String key : hashMap.keySet()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> hashMap.get(key);</span><br><span class="line">    System.out.println(key + <span class="string">&quot; 对应的值为：&quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-LinkedHashMap"><a href="#4-2-LinkedHashMap" class="headerlink" title="4.2 LinkedHashMap"></a>4.2 LinkedHashMap</h4><p><code>HashMap</code> 已经非常强大了，但它是无序的。如果我们需要一个有序的 <code>Map</code>，就要用到<code>LinkedHashMap</code> 是 <code>HashMap</code> 的子类，它使用链表来记录插入&#x2F;访问元素的顺序。</p>
<p><code>LinkedHashMap</code> 可以看作是 <code>HashMap</code> + <code>LinkedList</code> 的合体，它使用了哈希表来存储数据，又用了双向链表来维持顺序。</p>
<p>来一个简单的例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 LinkedHashMap，插入的键值对为 banana apple cherry</span></span><br><span class="line">LinkedHashMap&lt;String, String&gt; linkedHashMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">linkedHashMap.put(<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">linkedHashMap.put(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">linkedHashMap.put(<span class="string">&quot;cherry&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 LinkedHashMap</span></span><br><span class="line"><span class="keyword">for</span> (String key : linkedHashMap.keySet()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> linkedHashMap.get(key);</span><br><span class="line">    System.out.println(key + <span class="string">&quot; 对应的值为：&quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">banana 对应的值为：1</span><br><span class="line">apple 对应的值为：2</span><br><span class="line">cherry 对应的值为：3</span><br></pre></td></tr></table></figure>

<p>从结果中可以看得出来，<code>LinkedHashMap</code> 维持了键值对的插入顺序。为了和 <code>LinkedHashMap</code> 做对比，我们用同样的数据试验一下 <code>HashMap</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个HashMap，插入的键值对为 banana apple cherry</span></span><br><span class="line">HashMap&lt;String, String&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">hashMap.put(<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;cherry&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 HashMap</span></span><br><span class="line"><span class="keyword">for</span> (String key : hashMap.keySet()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> hashMap.get(key);</span><br><span class="line">    System.out.println(key + <span class="string">&quot; 对应的值为：&quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">banana 对应的值为：1</span><br><span class="line">cherry 对应的值为：3</span><br><span class="line">apple 对应的值为：2</span><br></pre></td></tr></table></figure>

<p><code>HashMap</code> 没有维持键值对的插入顺序。</p>
<h4 id="4-3-TreeMap"><a href="#4-3-TreeMap" class="headerlink" title="4.3 TreeMap"></a>4.3 TreeMap</h4><p>实现了 <code>SortedMap</code> 接口，可以自动将键按照自然顺序或指定的比较器顺序排序，并保证其元素的顺序。内部使用红黑树来实现键的排序和查找。</p>
<p>同样来一个增删改查的 <code>demo</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 TreeMap 对象</span></span><br><span class="line">Map&lt;String, String&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向 TreeMap 中添加键值对</span></span><br><span class="line">treeMap.put(<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">treeMap.put(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">treeMap.put(<span class="string">&quot;cherry&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找键值对</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;banana&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (treeMap.containsKey(name)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;找到了 &quot;</span> + name + <span class="string">&quot;: &quot;</span> + treeMap.get(name));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;没有找到 &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改键值对</span></span><br><span class="line">name = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (treeMap.containsKey(name)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;修改前的 &quot;</span> + name + <span class="string">&quot;: &quot;</span> + treeMap.get(name));</span><br><span class="line">    treeMap.put(name, <span class="string">&quot;new2&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;修改后的 &quot;</span> + name + <span class="string">&quot;: &quot;</span> + treeMap.get(name));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;没有找到 &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除键值对</span></span><br><span class="line">name = <span class="string">&quot;cherry&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (treeMap.containsKey(name)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;删除前的 &quot;</span> + name + <span class="string">&quot;: &quot;</span> + treeMap.get(name));</span><br><span class="line">    treeMap.remove(name);</span><br><span class="line">    System.out.println(<span class="string">&quot;删除后的 &quot;</span> + name + <span class="string">&quot;: &quot;</span> + treeMap.get(name));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;没有找到 &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 TreeMap</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : treeMap.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 <code>HashMap</code> 不同的是，<code>TreeMap</code> 会按照键的顺序来进行排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 TreeMap 对象</span></span><br><span class="line">Map&lt;String, String&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向 TreeMap 中添加键值对</span></span><br><span class="line">treeMap.put(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;cat&quot;</span>);</span><br><span class="line">treeMap.put(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line">treeMap.put(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 TreeMap</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : treeMap.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a: apple</span><br><span class="line">b: banana</span><br><span class="line">c: cat</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/GXKJDX/blog/2025/04/11/Java%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88/" data-id="cm2ahnlmc000dp0u45894b70n" data-title="五、Java基础-集合" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-JavaScript-js数组常用的方法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/2024/10/15/JavaScript-js%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2024-10-15T14:32:50.000Z" itemprop="datePublished">2024-10-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/2024/10/15/JavaScript-js%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/">一、JavaScript-数组</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="1-JavaScript-数组常用的方法"><a href="#1-JavaScript-数组常用的方法" class="headerlink" title="1 JavaScript 数组常用的方法"></a>1 JavaScript 数组常用的方法</h4><h5 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h5><p><code>值 =&gt; 表达式</code> 代表的是一个箭头函数的定义方式。下面是更详细的解释：</p>
<ul>
<li><p><strong>值</strong>：这是箭头函数的参数，可以是一个或多个参数。如果只有一个参数，可以省略圆括号；如果有多个参数，则必须使用圆括号包裹起来。</p>
<p>例如：</p>
<ul>
<li>单个参数：<code>num =&gt; ...</code></li>
<li>多个参数：<code>(num, num2) =&gt; ...</code></li>
</ul>
</li>
<li><p><strong>表达式</strong>：这是箭头函数的主体。如果箭头函数只有一个表达式，那么可以省略花括号（<code>&#123;&#125;</code>）和 <code>return</code> 关键字，直接返回这个表达式的结果。</p>
<p>例如：</p>
<ul>
<li><code>num =&gt; num * 2</code>：返回 <code>num</code> 的两倍。</li>
<li><code>num =&gt; &#123; console.log(num); &#125;</code>：打印 <code>num</code>，但因为有花括号，所以需要使用 <code>return</code> 才能返回值。</li>
</ul>
</li>
</ul>
<p><code>[...array]</code>：</p>
<ul>
<li><p>这是扩展运算符（Spread Operator）的使用，它用于将数组 <code>numbers</code> 的所有元素展开成一个新的数组。</p>
<p>例如：</p>
<ul>
<li><code>const array = [1, 9, 6, 3, 7, 4, 5]</code>; <code>const sorted = [...array]</code>; <code>sorted</code>是复制原数组得到的新数组。</li>
</ul>
</li>
</ul>
<h5 id="1-纯数组"><a href="#1-纯数组" class="headerlink" title="1 纯数组"></a>1 纯数组</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach() （循环遍历数组）</span></span><br><span class="line">numbers.<span class="title function_">forEach</span>(<span class="function"><span class="params">num</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(num)); <span class="comment">// 1, 9, 6, 3, 7, 4, 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map() （创建新数组，包含每个元素的平方）</span></span><br><span class="line"><span class="keyword">const</span> squares = numbers.<span class="title function_">map</span>(<span class="function"><span class="params">num</span> =&gt;</span> num * num);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(squares); <span class="comment">// [1, 81, 36, 9, 49, 16, 25]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filter() （过滤出大于5的元素）</span></span><br><span class="line"><span class="keyword">const</span> filtered = numbers.<span class="title function_">filter</span>(<span class="function"><span class="params">num</span> =&gt;</span> num &gt; <span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(filtered); <span class="comment">// [9, 6, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce() （计算数组元素的总和）</span></span><br><span class="line"><span class="keyword">const</span> sum = numbers.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, num</span>) =&gt;</span> acc + num, <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum); <span class="comment">// 35</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find() （查找第一个大于5的元素）</span></span><br><span class="line"><span class="keyword">const</span> found = numbers.<span class="title function_">find</span>(<span class="function"><span class="params">num</span> =&gt;</span> num &gt; <span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(found); <span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// some() （检查是否存在偶数）</span></span><br><span class="line"><span class="keyword">const</span> hasEven = numbers.<span class="title function_">some</span>(<span class="function"><span class="params">num</span> =&gt;</span> num % <span class="number">2</span> === <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hasEven); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// every() （检查是否所有元素都是正数）</span></span><br><span class="line"><span class="keyword">const</span> allPositive = numbers.<span class="title function_">every</span>(<span class="function"><span class="params">num</span> =&gt;</span> num &gt; <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(allPositive); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sort() （按升序排序数组）</span></span><br><span class="line"><span class="keyword">const</span> sorted = [...numbers].<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sorted); <span class="comment">// [1, 3, 4, 5, 6, 7, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reverse() （反转数组顺序）</span></span><br><span class="line"><span class="keyword">const</span> reversed = [...numbers].<span class="title function_">reverse</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reversed); <span class="comment">// [5, 4, 7, 3, 6, 9, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// includes() （检查数组是否包含5）</span></span><br><span class="line"><span class="keyword">const</span> includesFive = numbers.<span class="title function_">includes</span>(<span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(includesFive); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// indexOf() （查找9在数组中的索引）</span></span><br><span class="line"><span class="keyword">const</span> index = numbers.<span class="title function_">indexOf</span>(<span class="number">9</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(index); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// splice() （删除索引2的元素，并插入100）</span></span><br><span class="line"><span class="keyword">const</span> modified = [...numbers];</span><br><span class="line">modified.<span class="title function_">splice</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(modified); <span class="comment">// [1, 9, 100, 3, 7, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// slice() （提取索引1到4的片段）</span></span><br><span class="line"><span class="keyword">const</span> sliced = numbers.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sliced); <span class="comment">// [9, 6, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// push() （向数组末尾添加元素）</span></span><br><span class="line">numbers.<span class="title function_">push</span>(<span class="number">10</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numbers); <span class="comment">// [1, 9, 6, 3, 7, 4, 5, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pop() （删除数组末尾的元素）</span></span><br><span class="line"><span class="keyword">const</span> popped = numbers.<span class="title function_">pop</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(popped); <span class="comment">// 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numbers); <span class="comment">// [1, 9, 6, 3, 7, 4, 5]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-数组对象"><a href="#2-数组对象" class="headerlink" title="2 数组对象"></a>2 数组对象</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">232</span>, <span class="attr">fnumber</span>: <span class="string">&quot;01030252_V1.0&quot;</span>, <span class="attr">fmaterialgroupname</span>: <span class="string">&quot;草甘膦水剂&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">233</span>, <span class="attr">fnumber</span>: <span class="string">&quot;01030252_V1.0&quot;</span>, <span class="attr">fmaterialgroupname</span>: <span class="string">&quot;妙耕桶签&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">234</span>, <span class="attr">fnumber</span>: <span class="string">&quot;01030252_V1.0&quot;</span>, <span class="attr">fmaterialgroupname</span>: <span class="string">&quot;41%草甘膦桶&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">255</span>, <span class="attr">fnumber</span>: <span class="string">&quot;01030252_V1.1&quot;</span>, <span class="attr">fmaterialgroupname</span>: <span class="string">&quot;外购半成品&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">256</span>, <span class="attr">fnumber</span>: <span class="string">&quot;01030252_V1.1&quot;</span>, <span class="attr">fmaterialgroupname</span>: <span class="string">&quot;妙耕桶签&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">257</span>, <span class="attr">fnumber</span>: <span class="string">&quot;01030252_V1.1&quot;</span>, <span class="attr">fmaterialgroupname</span>: <span class="string">&quot;41%草甘膦桶&quot;</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach() （循环遍历数组对象）</span></span><br><span class="line">data.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(item)); <span class="comment">// 打印每个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map() （提取fnumber属性，创建新数组）</span></span><br><span class="line"><span class="keyword">const</span> fnumbers = data.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">fnumber</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fnumbers); <span class="comment">// [&quot;01030252_V1.0&quot;, &quot;01030252_V1.0&quot;, &quot;01030252_V1.0&quot;, &quot;01030252_V1.1&quot;, &quot;01030252_V1.1&quot;, &quot;01030252_V1.1&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filter() （过滤出唯一的fnumber对象）</span></span><br><span class="line"><span class="keyword">const</span> uniqueItems = data.<span class="title function_">filter</span>(<span class="function">(<span class="params">item, index, self</span>) =&gt;</span></span><br><span class="line">    index === self.<span class="title function_">findIndex</span>(<span class="function"><span class="params">t</span> =&gt;</span> t.<span class="property">fnumber</span> === item.<span class="property">fnumber</span>)</span><br><span class="line">);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uniqueItems); <span class="comment">// 唯一fnumber的对象数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce() （统计每个fnumber的数量）</span></span><br><span class="line"><span class="keyword">const</span> countByFnumber = data.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, item</span>) =&gt;</span> &#123;</span><br><span class="line">    acc[item.<span class="property">fnumber</span>] = (acc[item.<span class="property">fnumber</span>] || <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(countByFnumber); <span class="comment">// &#123; &quot;01030252_V1.0&quot;: 3, &quot;01030252_V1.1&quot;: 3 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find() （查找包含“桶”的项目）</span></span><br><span class="line"><span class="keyword">const</span> foundItem = data.<span class="title function_">find</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">fmaterialgroupname</span>.<span class="title function_">includes</span>(<span class="string">&quot;桶&quot;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foundItem); <span class="comment">// 找到的第一个包含“桶”的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// some() （检查是否存在“草”的产品）</span></span><br><span class="line"><span class="keyword">const</span> hasGrass = data.<span class="title function_">some</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">fmaterialgroupname</span>.<span class="title function_">includes</span>(<span class="string">&quot;草&quot;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hasGrass); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// every() （检查所有对象是否都有id属性）</span></span><br><span class="line"><span class="keyword">const</span> allHaveId = data.<span class="title function_">every</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">id</span> !== <span class="literal">undefined</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(allHaveId); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sort() （按id排序数组对象）</span></span><br><span class="line"><span class="keyword">const</span> sortedById = [...data].<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="property">id</span> - b.<span class="property">id</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sortedById); <span class="comment">// 按id升序排序的对象数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reverse() （反转数组对象顺序）</span></span><br><span class="line"><span class="keyword">const</span> reversedData = [...data].<span class="title function_">reverse</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reversedData); <span class="comment">// 反转后的对象数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// includes() （检查fnumber数组中是否存在某个值）</span></span><br><span class="line"><span class="keyword">const</span> fnumberExists = fnumbers.<span class="title function_">includes</span>(<span class="string">&quot;01030252_V1.0&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fnumberExists); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// indexOf() （查找某个fnumber在数组中的索引）</span></span><br><span class="line"><span class="keyword">const</span> indexOfFnumber = fnumbers.<span class="title function_">indexOf</span>(<span class="string">&quot;01030252_V1.0&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(indexOfFnumber); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// splice() （删除索引2的对象，并插入新对象）</span></span><br><span class="line"><span class="keyword">const</span> modifiedData = [...data];</span><br><span class="line">modifiedData.<span class="title function_">splice</span>(<span class="number">2</span>, <span class="number">1</span>, &#123; <span class="attr">id</span>: <span class="number">300</span>, <span class="attr">fnumber</span>: <span class="string">&quot;新项目&quot;</span>, <span class="attr">fmaterialgroupname</span>: <span class="string">&quot;新材料&quot;</span> &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(modifiedData); <span class="comment">// 删除后的新数组对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// slice() （提取数组对象的片段）</span></span><br><span class="line"><span class="keyword">const</span> slicedData = data.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(slicedData); <span class="comment">// [索引1到4的对象数组]</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/GXKJDX/blog/2024/10/15/JavaScript-js%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/" data-id="cm9cvl5dd0000v0u4bcgchtek" data-title="一、JavaScript-数组" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Java基础-面试题40-46" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/2024/08/27/Java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E8%AF%95%E9%A2%9840-46/" class="article-date">
  <time class="dt-published" datetime="2024-08-27T14:32:50.000Z" itemprop="datePublished">2024-08-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/2024/08/27/Java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E8%AF%95%E9%A2%9840-46/">四、Java基础-面试题40-46</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>前言</strong>：Java 中修饰符（访问控制符）</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>当前类</th>
<th>同包类</th>
<th>子类</th>
<th>其他包</th>
</tr>
</thead>
<tbody><tr>
<td><code>public</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td><code>protected</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>无修饰符 (默认)</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td><code>private</code></td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
</tbody></table>
<h5 id="40-为什么JDK-9中把String的char-改成了byte-？"><a href="#40-为什么JDK-9中把String的char-改成了byte-？" class="headerlink" title="40 为什么JDK 9中把String的char[]改成了byte[]？"></a>40 为什么JDK 9中把String的char[]改成了byte[]？</h5><p>40.1 <strong>内存占用减少</strong>：<code>char[]</code> 数组中每个字符占用两个字节（16位），这是因为 <code>char</code> 类型在 Java 中是基于 UTF-16 编码的。而大多数字符串其实只需要一个字节（8位）就能表示一个字符（特别是英文、数字等）。通过将底层存储从 <code>char[]</code> 改为 <code>byte[]</code>，可以减少内存消耗。</p>
<p>40.2 <strong>提高性能</strong>：通过减少内存占用，可以在一定程度上提高 CPU 缓存的利用率，从而提高字符串操作的性能。</p>
<h5 id="41-Arrays-sort是使用什么排序算法实现的？"><a href="#41-Arrays-sort是使用什么排序算法实现的？" class="headerlink" title="41 Arrays.sort是使用什么排序算法实现的？"></a>41 Arrays.sort是使用什么排序算法实现的？</h5><p>快速排序</p>
<h5 id="42-字符串常量是什么时候进入到字符串常量池的？"><a href="#42-字符串常量是什么时候进入到字符串常量池的？" class="headerlink" title="42 字符串常量是什么时候进入到字符串常量池的？"></a>42 字符串常量是什么时候进入到字符串常量池的？</h5><p><strong>前言</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+--------------------------------------+</span><br><span class="line">|              JVM                     |</span><br><span class="line">|  +--------------------------------+  |</span><br><span class="line">|  |       Method Area              |  |</span><br><span class="line">|  |  +--------------------------+  |  |</span><br><span class="line">|  |  |   Constant Pool          |  |  |</span><br><span class="line">|  |  +--------------------------+  |  |</span><br><span class="line">|  |                                |  |</span><br><span class="line">|  +--------------------------------+  |</span><br><span class="line">|                                      |</span><br><span class="line">|  +--------------------------------+  |</span><br><span class="line">|  |            Heap                |  |</span><br><span class="line">|  +--------------------------------+  |</span><br><span class="line">|                                      |</span><br><span class="line">|  +--------------------------------+  |</span><br><span class="line">|  |      Stack (per thread)        |  |</span><br><span class="line">|  |  +--------------------------+  |  |</span><br><span class="line">|  |  |     Stack Frames         |  |  |</span><br><span class="line">|  |  +--------------------------+  |  |</span><br><span class="line">|  +--------------------------------+  |</span><br><span class="line">+--------------------------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：</p>
<ul>
<li><strong>JVM (Java Virtual Machine)</strong>: 整体虚拟机结构，包含以下各个区域。</li>
<li><strong>Method Area</strong>: 存储已加载的类信息、常量、静态变量和JIT编译后的代码。</li>
<li><strong>Constant Pool (常量池)</strong>: 是Method Area的一部分，存储编译期生成的各种字面量和符号引用。</li>
<li><strong>Heap (堆)</strong>: 存储所有对象实例和数组，是被所有线程共享的一块内存区域。</li>
<li><strong>Stack (栈)</strong>: 每个线程都有自己的栈，栈中包含多个栈帧（Stack Frames），每个栈帧对应一个方法的调用，保存方法的局部变量、操作数栈、方法返回地址等。</li>
</ul>
<p><strong>编译时示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>&quot;hello&quot;</code> 字符串在<strong>编译时</strong>已经放入字符串常量池，<code>s1</code> 和 <code>s2</code> 变量都指向这个池中的同一个字符串对象。</p>
<p><strong>运行时示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// false, 因为 s1 指向堆中的对象，而 s2 指向字符串池中的对象</span></span><br><span class="line">System.out.println(s2 == s3); <span class="comment">// true, 因为 s2 和 s3 都指向字符串池中的 &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>intern()</code> 方法的作用是：检查字符串常量池中是否已经包含了一个等于当前字符串的对象。在这个例子中，<code>s1</code> 是一个在堆中创建的字符串对象，<code>s2</code> 则是 <code>s1.intern()</code> 返回的引用，这个引用指向字符串常量池中的 <code>&quot;hello&quot;</code>。</p>
<p><strong>总结</strong>：</p>
<ul>
<li><strong>编译时</strong>：字符串字面量直接进入字符串常量池。</li>
<li><strong>运行时</strong>：如果字符串池中已经存在一个等于该字符串的对象， <code>intern()</code> 方法会返回这个已存在的对象的引用，通过 <code>intern()</code> 方法可以将字符串加入字符串常量池（如果该字符串不在常量池中）。</li>
</ul>
<h5 id="43-Java中Timer实现定时调度的原理是什么？"><a href="#43-Java中Timer实现定时调度的原理是什么？" class="headerlink" title="43 Java中Timer实现定时调度的原理是什么？"></a>43 Java中Timer实现定时调度的原理是什么？</h5><ul>
<li><p><code>Timer</code> 的任务队列是优先队列，按照任务的执行时间优先级进行排序。</p>
</li>
<li><p>后台线程会根据优先队列中任务的执行时间来决定何时执行任务，并在合适的时间点触发任务的执行。</p>
</li>
</ul>
<p>总结：<code>Timer</code> 的定时调度通过后台线程不断检查任务队列，并根据任务的执行时间安排任务的执行。可以使用 <code>Timer</code> 类来实现简单的定时调度任务，但要注意它的局限性（如单线程执行、异常处理等）。</p>
<h5 id="44-final、finally、finalize有什么区别？"><a href="#44-final、finally、finalize有什么区别？" class="headerlink" title="44 final、finally、finalize有什么区别？"></a>44 final、finally、finalize有什么区别？</h5><p><strong><code>final</code> 关键字</strong></p>
<ul>
<li><p><strong>修饰类</strong>：当一个类被声明为 <code>final</code>，它不能被继承。例如，<code>String</code> 类就是一个 <code>final</code> 类。</p>
</li>
<li><p><strong>修饰方法</strong>：当一个方法被声明为 <code>final</code>，它不能被子类覆盖（override）。</p>
</li>
<li><p><strong>修饰变量</strong>：当一个变量被声明为 <code>final</code>，它的值在初始化之后不能再被修改。对于基本数据类型，<code>final</code> 变量不可变；对于引用类型，<code>final</code> 使引用不可改变，但引用指向的对象内容是可以改变的。</p>
</li>
</ul>
<p><strong><code>finally</code> 代码块</strong></p>
<p><code>finally</code> 是一个代码块，用于异常处理机制中。无论是否发生异常，<code>finally</code> 块中的代码都会被执行。它通常用于清理资源，如关闭文件、释放数据库连接等。</p>
<p><strong><code>finalize()</code> 方法</strong></p>
<p><code>finalize()</code>是一个方法，用于垃圾收集之前的清理操作，不推荐使用，并在Java 9 已被弃用。</p>
<h5 id="44-为什么建议自定义一个无参构造函数？"><a href="#44-为什么建议自定义一个无参构造函数？" class="headerlink" title="44 为什么建议自定义一个无参构造函数？"></a>44 为什么建议自定义一个无参构造函数？</h5><p>44.1 如果你定义了一个有参构造函数，那么Java编译器将不会自动创建无参构造函数，当你直接实例化该类，会造成编译错误，示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参数的构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有显式定义无参构造函数</span></span><br><span class="line">    <span class="comment">// MyClass obj = new MyClass(); // 这行代码会导致编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>44.2 支持框架和库的使用(通常是用于反射或序列化)</p>
<p>许多框架和库（例如 Hibernate、Spring）在反射或序列化过程中，需要通过无参构造函数来创建对象实例。如果类中没有无参构造函数，可能会导致这些框架或库的功能失效或抛出异常。</p>
<p><strong>Hibernate</strong>：通常需要无参构造函数来实例化实体类，因为它使用反射机制来创建对象。</p>
<p><strong>Spring</strong>：在使用依赖注入时，如果需要自动装配的类没有无参构造函数，可能会导致 Spring 无法实例化该类。</p>
<h5 id="45-为什么不建议使用异常控制业务流程？"><a href="#45-为什么不建议使用异常控制业务流程？" class="headerlink" title="45 为什么不建议使用异常控制业务流程？"></a>45 为什么不建议使用异常控制业务流程？</h5><p>1.<strong>异常的语义</strong> 2.<strong>性能开销</strong> 3.<strong>代码可读性和维护性</strong> 4. <strong>业务逻辑的复杂性</strong></p>
<h5 id="46-有了equals为啥需要hashCode方法？"><a href="#46-有了equals为啥需要hashCode方法？" class="headerlink" title="46 有了equals为啥需要hashCode方法？"></a>46 有了equals为啥需要hashCode方法？</h5><p>46.1 <code>equals()</code> 方法</p>
<p><code>equals()</code> 方法用于比较两个对象的内容是否相同。</p>
<p>46.2 <code>hashCode()</code> 方法</p>
<p><code>hashCode()</code> 方法返回一个整数，称为对象的哈希码。</p>
<p>46.3 <code>equals()</code> 和 <code>hashCode()</code> 的合同（约定）</p>
<p>Java 中有一个非常重要的约定：<strong>如果两个对象根据 <code>equals()</code> 方法比较是相等的，那么它们的 <code>hashCode()</code> 值必须相等</strong>。但是，反过来不一定成立：如果两个对象的 <code>hashCode()</code> 值相等，它们并不一定根据 <code>equals()</code> 方法相等。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashCode</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashSet&lt;HashPerson&gt; people = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        people.add(<span class="keyword">new</span> <span class="title class_">HashPerson</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>));</span><br><span class="line">        people.add(<span class="keyword">new</span> <span class="title class_">HashPerson</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>)); <span class="comment">// 应该与第一个对象相等</span></span><br><span class="line"></span><br><span class="line">        System.out.println(people.size()); <span class="comment">// 如果没有重写 hashCode，可能会输出 2 而不是 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashPerson</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashPerson</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 检查首先判断当前对象 this 和参数对象 o 是否是同一个对象（即引用相同）</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果 o 为 null，或者 o 的类型与当前对象的类型不同（即它们不是同一个类的实例），则返回 false，表示它们不相等。</span></span><br><span class="line">        <span class="type">HashPerson</span> <span class="variable">person</span> <span class="operator">=</span> (HashPerson) o; <span class="comment">// 这里将对象 o 强制转换为 HashPerson 类型。因为前面的类型检查已经确保了 o 是 HashPerson 的实例，这种转换是安全的。</span></span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp; Objects.equals(name, person.name);</span><br><span class="line">        <span class="comment">// age == person.age 直接比较两个对象的 age 是否相等（基本类型 int 的比较）。</span></span><br><span class="line">        <span class="comment">// Objects.equals(name, person.name) 比较两个 String 对象 name 是否相等，Objects.equals() 方法避免了 null 指针异常，如果 name 是 null，它会安全地返回 false。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age); <span class="comment">// Objects.hash() 是一个便捷方法，它接受可变数量的参数（这里是 name 和 age），并基于这些参数生成一个哈希码。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/GXKJDX/blog/2024/08/27/Java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E8%AF%95%E9%A2%9840-46/" data-id="cm2ahnlmf000op0u4erayev2p" data-title="四、Java基础-面试题40-46" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-SpringBoot-Java Bean Validation 注解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/2024/08/27/SpringBoot-Java%20Bean%20Validation%20%E6%B3%A8%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2024-08-27T14:32:50.000Z" itemprop="datePublished">2024-08-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/2024/08/27/SpringBoot-Java%20Bean%20Validation%20%E6%B3%A8%E8%A7%A3/">一、SpringBoot Java Bean Validation 注解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>常用的 Java Bean Validation 注解包括：</p>
<ul>
<li>校验空值：<code>@NotNull</code>, <code>@NotEmpty</code>, <code>@NotBlank</code>, <code>@Null</code></li>
<li>校验长度：<code>@Size</code>, <code>@Length</code></li>
<li>校验数字：<code>@Min</code>, <code>@Max</code>, <code>@DecimalMin</code>, <code>@DecimalMax</code>, <code>@Range</code>, <code>@Digits</code></li>
<li>校验日期：<code>@Past</code>, <code>@Future</code></li>
<li>校验格式：<code>@Email</code>, <code>@Pattern</code></li>
<li>校验布尔值：<code>@AssertTrue</code>, <code>@AssertFalse</code></li>
<li>校验对象嵌套：<code>@Valid</code></li>
</ul>
<h3 id="1-空值校验相关注解"><a href="#1-空值校验相关注解" class="headerlink" title="1. 空值校验相关注解"></a><strong>1. 空值校验相关注解</strong></h3><p><strong><code>@NotNull</code></strong></p>
<ul>
<li><p>校验字段值是否为 <code>null</code>，不允许为 <code>null</code>。</p>
</li>
<li><p>适用类型：所有对象类型。</p>
</li>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotNull(message = &quot;用户名不能为空&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String userName;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>@NotEmpty</code></strong></p>
<ul>
<li><p>校验字段是否为空，适用于 <strong>字符串、集合、数组、Map</strong> 等类型，不能为空或长度为0。</p>
</li>
<li><p>适用类型：字符串、集合、数组、Map。</p>
</li>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotEmpty(message = &quot;用户名不能为空&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String userName;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>@NotBlank</code></strong></p>
<ul>
<li><p>校验字段是否为非空字符串，并且不能为空或只包含空白字符。</p>
</li>
<li><p>适用类型：字符串。</p>
</li>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotBlank(message = &quot;用户名不能为空&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String userName;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>@Null</code></strong></p>
<ul>
<li><p>校验字段值是否为 <code>null</code>，通常用于校验不允许赋值的字段。</p>
</li>
<li><p>适用类型：所有对象类型。</p>
</li>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Null(message = &quot;字段必须为空&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String someField;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-长度校验相关注解"><a href="#2-长度校验相关注解" class="headerlink" title="2. 长度校验相关注解"></a><strong>2. 长度校验相关注解</strong></h3><p><strong><code>@Size</code></strong></p>
<ul>
<li><p>校验字符串、集合、数组的长度。</p>
</li>
<li><p>适用类型：字符串、集合、数组。</p>
</li>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Size(min = 5, max = 20, message = &quot;用户名长度必须在5到20之间&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String userName;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>@Length</code></strong> (Hibernate Validator)</p>
<ul>
<li><p>校验字符串的长度，类似于 <code>@Size</code>，但它专门用于字符串长度校验。</p>
</li>
<li><p>适用类型：字符串。</p>
</li>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Length(min = 5, max = 10, message = &quot;密码长度必须在5到10之间&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String password;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="3-数值范围校验相关注解"><a href="#3-数值范围校验相关注解" class="headerlink" title="3. 数值范围校验相关注解"></a><strong>3. 数值范围校验相关注解</strong></h3><p><strong><code>@Min</code></strong></p>
<ul>
<li><p>校验字段值是否大于或等于指定的最小值。</p>
</li>
<li><p>适用类型：数值类型（<code>int</code>, <code>long</code>, <code>double</code>）。</p>
</li>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Min(value = 18, message = &quot;年龄不能小于18岁&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>@Max</code></strong></p>
<ul>
<li><p>校验字段值是否小于或等于指定的最大值。</p>
</li>
<li><p>适用类型：数值类型（<code>int</code>, <code>long</code>, <code>double</code>）。</p>
</li>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Max(value = 100, message = &quot;年龄不能大于100岁&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>@DecimalMin</code> 和 <code>@DecimalMax</code></strong></p>
<ul>
<li><p>校验小数类型字段的最小值和最大值。</p>
</li>
<li><p>适用类型：<code>BigDecimal</code> 或 <code>double</code> 类型。</p>
</li>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DecimalMin(value = &quot;0.0&quot;, inclusive = true, message = &quot;金额不能小于0&quot;)</span></span><br><span class="line"><span class="keyword">private</span> BigDecimal amount;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>@Range</code></strong> (Hibernate Validator)</p>
<ul>
<li><p>校验字段值是否在指定范围内，适用于数值类型。</p>
</li>
<li><p>适用类型：数值类型（<code>int</code>, <code>long</code>, <code>BigDecimal</code> 等）。</p>
</li>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Range(min = 1, max = 100, message = &quot;数值必须在1到100之间&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> rangeValue;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>@Digits</code></strong></p>
<ul>
<li><p>校验数字是否符合规定的整数位和小数位的范围。</p>
</li>
<li><p>适用类型：<code>BigDecimal</code>、<code>double</code> 等数值类型。</p>
</li>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Digits(integer = 10, fraction = 2, message = &quot;价格必须是数字，且最多两位小数&quot;)</span></span><br><span class="line"><span class="keyword">private</span> BigDecimal price;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="4-日期相关校验注解"><a href="#4-日期相关校验注解" class="headerlink" title="4. 日期相关校验注解"></a><strong>4. 日期相关校验注解</strong></h3><p><strong><code>@Past</code></strong></p>
<ul>
<li><p>校验日期是否是过去的日期。</p>
</li>
<li><p>适用类型：<code>java.util.Date</code> 或 <code>java.time</code> 类。</p>
</li>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Past(message = &quot;出生日期必须是过去的日期&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Date birthDate;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>@Future</code></strong></p>
<ul>
<li><p>校验日期是否是未来的日期。</p>
</li>
<li><p>适用类型：<code>java.util.Date</code> 或 <code>java.time</code> 类。</p>
</li>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Future(message = &quot;交付日期必须是未来日期&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Date deliveryDate;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="5-格式校验相关注解"><a href="#5-格式校验相关注解" class="headerlink" title="5. 格式校验相关注解"></a><strong>5. 格式校验相关注解</strong></h3><p><strong><code>@Email</code></strong></p>
<ul>
<li><p>校验字段值是否为有效的电子邮件格式。</p>
</li>
<li><p>适用类型：<code>String</code>。</p>
</li>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Email(message = &quot;请输入有效的邮箱地址&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String email;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>@Pattern</code></strong></p>
<ul>
<li><p>校验字段值是否符合指定的正则表达式。</p>
</li>
<li><p>适用类型：<code>String</code>。</p>
</li>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pattern(regexp = &quot;^[a-zA-Z0-9_]+$&quot;, message = &quot;用户名只能包含字母、数字和下划线&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String userName;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="6-布尔值校验注解"><a href="#6-布尔值校验注解" class="headerlink" title="6. 布尔值校验注解"></a><strong>6. 布尔值校验注解</strong></h3><p><strong><code>@AssertTrue</code></strong></p>
<ul>
<li><p>校验字段值是否为 <code>true</code>。</p>
</li>
<li><p>适用类型：<code>boolean</code> 或 <code>Boolean</code>。</p>
</li>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AssertTrue(message = &quot;必须同意用户协议&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> agreeTerms;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>@AssertFalse</code></strong></p>
<ul>
<li><p>校验字段值是否为 <code>false</code>。</p>
</li>
<li><p>适用类型：<code>boolean</code> 或 <code>Boolean</code>。</p>
</li>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AssertFalse(message = &quot;此操作不可执行&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> operationForbidden;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="7-对象校验相关注解"><a href="#7-对象校验相关注解" class="headerlink" title="7. 对象校验相关注解"></a><strong>7. 对象校验相关注解</strong></h3><p><code>@Valid</code></p>
<ul>
<li><p>用于嵌套对象的校验。</p>
</li>
<li><p>适用类型：嵌套对象。</p>
</li>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="keyword">private</span> Address address; <span class="comment">// Address 类也有自己的校验规则</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="8-其他校验注解"><a href="#8-其他校验注解" class="headerlink" title="8. 其他校验注解"></a><strong>8. 其他校验注解</strong></h3><p><code>@NotBlank</code> (Spring)</p>
<ul>
<li><p>校验字段是否为非空且不为仅空白字符。</p>
</li>
<li><p>适用类型：<code>String</code>。</p>
</li>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotBlank(message = &quot;用户名不能为空&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String userName;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="常见的使用场景和示例"><a href="#常见的使用场景和示例" class="headerlink" title="常见的使用场景和示例"></a>常见的使用场景和示例</h3><h4 id="1-校验请求参数（请求体）"><a href="#1-校验请求参数（请求体）" class="headerlink" title="1. 校验请求参数（请求体）"></a>1. <strong>校验请求参数（请求体）</strong></h4><p>在 Spring Boot 控制器中，常见的场景是校验 POST 或 PUT 请求中的请求体。假设你有一个用户注册接口，需要校验用户信息：</p>
<p><strong>User.java（实体类）</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.validation.constraints.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;用户名不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Size(min = 5, max = 30, message = &quot;用户名长度必须在5到30之间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;密码不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Size(min = 8, max = 20, message = &quot;密码长度必须在8到20之间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Email(message = &quot;邮箱格式不正确&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>UserController.java（控制器）</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.validation.annotation.Validated;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> javax.validation.Valid;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过@Valid触发校验</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/register&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">register</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果校验失败，会自动返回400错误，提示校验信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;用户注册成功!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-校验查询参数"><a href="#2-校验查询参数" class="headerlink" title="2. 校验查询参数"></a>2. <strong>校验查询参数</strong></h4><p>除了请求体中的数据，很多时候我们也需要校验查询参数。例如，校验用户的查询条件（如分页参数、排序字段等）：</p>
<p><strong>QueryParams.java（查询参数类）</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.validation.constraints.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueryParams</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Min(value = 1, message = &quot;页码不能小于1&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> page;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Min(value = 1, message = &quot;每页记录数不能小于1&quot;)</span></span><br><span class="line">    <span class="meta">@Max(value = 100, message = &quot;每页记录数不能超过100&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pattern(regexp = &quot;name|email|phone&quot;, message = &quot;排序字段不合法&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pattern(regexp = &quot;asc|desc&quot;, message = &quot;排序方式不合法&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String sortOrder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>UserController.java（控制器）</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过@Validated触发校验（校验查询参数）</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getUserList</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@ModelAttribute</span> QueryParams queryParams)</span> &#123;</span><br><span class="line">        <span class="comment">// 查询逻辑</span></span><br><span class="line">        <span class="keyword">return</span> userService.getUserList(queryParams);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>@Validated</code> 触发了对 <code>QueryParams</code> 的校验，确保 <code>page</code>、<code>size</code> 和 <code>sortBy</code> 等字段符合预期的规则。</p>
<h4 id="3-校验嵌套对象"><a href="#3-校验嵌套对象" class="headerlink" title="3. 校验嵌套对象"></a>3. <strong>校验嵌套对象</strong></h4><p>当一个对象内嵌有其他对象时，可以使用 <code>@Valid</code> 或 <code>@Validated</code> 来递归触发嵌套对象的校验。</p>
<p><strong>Address.java（嵌套对象）</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.validation.constraints.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;省份不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String province;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;城市不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;街道不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String street;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>User.java（包含嵌套对象）</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.validation.constraints.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;用户名不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Valid</span>  <span class="comment">// 触发嵌套对象Address的校验</span></span><br><span class="line">    <span class="keyword">private</span> Address address;  <span class="comment">// 地址对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>UserController.java（控制器）</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/create&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">createUser</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 当User的address字段校验失败时，会自动返回400错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;用户创建成功!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>User</code> 类有一个嵌套的 <code>Address</code> 类，通过 <code>@Valid</code> 注解，Spring 会自动校验 <code>Address</code> 类中的字段。</p>
<h4 id="4-校验更新操作的字段（使用校验分组）"><a href="#4-校验更新操作的字段（使用校验分组）" class="headerlink" title="4. 校验更新操作的字段（使用校验分组）"></a>4. <strong>校验更新操作的字段（使用校验分组）</strong></h4><p>在某些情况下，针对不同操作（如创建、更新）会有不同的校验规则。可以通过校验分组来实现不同场景下的校验。</p>
<p><strong>CreateGroup.java（分组接口）</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CreateGroup</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>UpdateGroup.java（分组接口）</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UpdateGroup</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>User.java（实体类）</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.validation.constraints.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;用户名不能为空&quot;, groups = &#123;CreateGroup.class, UpdateGroup.class&#125;)</span></span><br><span class="line">    <span class="meta">@Size(min = 5, max = 30, message = &quot;用户名长度必须在5到30之间&quot;, groups = &#123;CreateGroup.class, UpdateGroup.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;密码不能为空&quot;, groups = &#123;CreateGroup.class&#125;)</span></span><br><span class="line">    <span class="meta">@Size(min = 8, max = 20, message = &quot;密码长度必须在8到20之间&quot;, groups = &#123;CreateGroup.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Email(message = &quot;邮箱格式不正确&quot;, groups = &#123;UpdateGroup.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>UserController.java（控制器）</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/create&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">createUser</span><span class="params">(<span class="meta">@Validated(CreateGroup.class)</span> <span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 仅校验CreateGroup中的字段</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;用户创建成功!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/update&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">updateUser</span><span class="params">(<span class="meta">@Validated(UpdateGroup.class)</span> <span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 仅校验UpdateGroup中的字段</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;用户更新成功!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过不同的校验分组，你可以在创建用户时校验用户名和密码，但在更新用户时只校验邮箱。</p>
<h4 id="5-校验集合对象"><a href="#5-校验集合对象" class="headerlink" title="5. 校验集合对象"></a>5. <strong>校验集合对象</strong></h4><p>如果一个字段是集合类型，且集合内的每个元素都需要校验，可以使用 <code>@Valid</code> 注解来校验集合中的每个元素。</p>
<p><strong>User.java（包含集合）</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.validation.constraints.*;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;用户名不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Valid</span>  <span class="comment">// 校验集合中的每个元素</span></span><br><span class="line">    <span class="meta">@NotEmpty(message = &quot;角色列表不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;<span class="meta">@NotNull(message = &quot;角色不能为空&quot;)</span> String&gt; roles;  <span class="comment">// 角色列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>UserController.java（控制器）</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/users&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/create&quot;)</span><br><span class="line">    public String createUser(@Valid @RequestBody User user) &#123;</span><br><span class="line">        // 校验失败时会返回400错误，提示哪些角色无效</span><br><span class="line">        return &quot;用户创建成功!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，如果 <code>roles</code> 中有 <code>null</code> 或者是空的，Spring 会根据注解规则抛出验证异常。</p>
<h4 id="6-校验方法参数（局部验证）"><a href="#6-校验方法参数（局部验证）" class="headerlink" title="6. 校验方法参数（局部验证）"></a>6. <strong>校验方法参数（局部验证）</strong></h4><p>除了全局校验（如类上的注解），你还可以在方法参数上进行校验。</p>
<p><strong>UserService.java（服务类）</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.validation.constraints.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUserInfo</span><span class="params">(<span class="meta">@NotNull</span> <span class="meta">@Size(min = 5)</span> String userName)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果userName不符合条件，会抛出ConstraintViolationException</span></span><br><span class="line">        System.out.println(<span class="string">&quot;用户名更新为：&quot;</span> + userName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>常见的校验注解使用示例包括：</p>
<ol>
<li><strong>校验请求参数</strong>：在 Spring 控制器中使用 <code>@Valid</code> 校验请求体或 <code>@Validated</code> 校验查询参数。</li>
<li><strong>校验嵌套对象</strong>：通过在父类对象字段上使用 <code>@Valid</code> 来校验嵌套对象。</li>
<li><strong>校验分组</strong>：使用不同的分组来为不同的操作（如创建、更新）定义不同的校验规则。</li>
<li><strong>校验集合对象</strong>：使用 <code>@Valid</code> 校验集合中的每个元素。</li>
<li><strong>校验方法参数</strong>：方法级别的校验，用于校验方法传入的参数。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/GXKJDX/blog/2024/08/27/SpringBoot-Java%20Bean%20Validation%20%E6%B3%A8%E8%A7%A3/" data-id="cm9cvl5df0001v0u46m2fbgq5" data-title="一、SpringBoot Java Bean Validation 注解" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/SpringBoot/" rel="tag">SpringBoot</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Java基础-面试题27-39" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/2024/08/26/Java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E8%AF%95%E9%A2%9827-39/" class="article-date">
  <time class="dt-published" datetime="2024-08-26T14:32:50.000Z" itemprop="datePublished">2024-08-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/2024/08/26/Java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E8%AF%95%E9%A2%9827-39/">三、Java基础-面试题27-39</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h5 id="前言-UML图示"><a href="#前言-UML图示" class="headerlink" title="前言 UML图示"></a>前言 UML图示</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">    class InterfaceA &#123;</span><br><span class="line">        &lt;&lt;interface&gt;&gt;</span><br><span class="line">        +methodA()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class InterfaceB &#123;</span><br><span class="line">        &lt;&lt;interface&gt;&gt;</span><br><span class="line">        +methodB()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class BaseClass &#123;</span><br><span class="line">        +baseMethod()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class DerivedClass &#123;</span><br><span class="line">        +methodA()</span><br><span class="line">        +methodB()</span><br><span class="line">        +derivedMethod()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BaseClass &lt;|-- DerivedClass</span><br><span class="line">    InterfaceA &lt;|.. DerivedClass</span><br><span class="line">    InterfaceB &lt;|.. DerivedClass</span><br></pre></td></tr></table></figure>

<h5 id="对应代码示例"><a href="#对应代码示例" class="headerlink" title="对应代码示例"></a>对应代码示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口 InterfaceA</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceA</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义接口 InterfaceB</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceB</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义基类 BaseClass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">baseMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Base method in BaseClass&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义继承自 BaseClass 并实现 InterfaceA 和 InterfaceB 的 DerivedClass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedClass</span> <span class="keyword">extends</span> <span class="title class_">BaseClass</span> <span class="keyword">implements</span> <span class="title class_">InterfaceA</span>, InterfaceB &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Method A implemented in DerivedClass&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Method B implemented in DerivedClass&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">derivedMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Derived method in DerivedClass&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DerivedClass</span> <span class="variable">derived</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DerivedClass</span>();</span><br><span class="line">        derived.baseMethod();    <span class="comment">// 来自 BaseClass</span></span><br><span class="line">        derived.methodA();       <span class="comment">// 实现自 InterfaceA</span></span><br><span class="line">        derived.methodB();       <span class="comment">// 实现自 InterfaceB</span></span><br><span class="line">        derived.derivedMethod(); <span class="comment">// DerivedClass 特有的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="27-异常类"><a href="#27-异常类" class="headerlink" title="27 异常类"></a>27 异常类</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[Throwable] --&gt; B[Exception]</span><br><span class="line">    A --&gt; C[Error]</span><br><span class="line">    </span><br><span class="line">    B --&gt; D[Checked Exception]</span><br><span class="line">    D --&gt; E[IOException]</span><br><span class="line">    D --&gt; F[SQLException]</span><br><span class="line">    D --&gt; G[ClassNotFoundException]</span><br><span class="line">    </span><br><span class="line">    B --&gt; H[RuntimeException]</span><br><span class="line">    H --&gt; I[NullPointerException]</span><br><span class="line">    H --&gt; J[ArrayIndexOutOfBoundsException]</span><br><span class="line">    H --&gt; K[ArithmeticException]</span><br><span class="line">    H --&gt; L[ClassCastException]</span><br><span class="line">    </span><br><span class="line">    C --&gt; M[OutOfMemoryError]</span><br><span class="line">    C --&gt; N[StackOverflowError]</span><br></pre></td></tr></table></figure>

<p><strong>图解说明：</strong></p>
<ul>
<li><code>Throwable</code> 是所有异常类的根类，继承<code>Object</code>，实现了序列化接口，<code>Exception</code>和<code>Error</code>是两个最重要的子类。</li>
<li>Exception是 Throwable的子类，表示可恢复的异常。<ul>
<li><code>Checked Exception</code> 是所有受检异常的统称，需要捕获，需要处理的异常，直接继承自 <code>Exception</code> 类。常见的子类有 <code>IOException</code>、<code>SQLException</code>、<code>ClassNotFoundException</code> 等。</li>
<li><code>RuntimeException</code> 是所有非受检异常的统称，继承自 <code>Exception</code> 类。常见的子类有 <code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code>、<code>ArithmeticException</code>、<code>ClassCastException</code> 等。</li>
</ul>
</li>
<li><code>Error</code> 是 <code>Throwable</code> 的另一个子类，表示系统级的严重错误，通常不需要捕获，程序无法自动解决，只有退出运行才能解决。常见的子类有 <code>OutOfMemoryError</code> 和 <code>StackOverflowError</code>。</li>
</ul>
<h5 id="28-说说Java异常处理相关的几个关键字，以及简单用法？"><a href="#28-说说Java异常处理相关的几个关键字，以及简单用法？" class="headerlink" title="28 说说Java异常处理相关的几个关键字，以及简单用法？"></a>28 说说Java异常处理相关的几个关键字，以及简单用法？</h5><p>throws、throw、try、catch、finally</p>
<ol>
<li>try 包裹执行语句</li>
<li>catch指定想要捕获的异常的类型</li>
<li>finally确保一段代码不管发生什么异常都要被执行</li>
<li>throw明确抛出一个异常</li>
<li>throws用来声明一个方法可能抛出的异常</li>
</ol>
<h5 id="29-try中return-A，catch中return-B，finally中return-C，最终返回值是什么？"><a href="#29-try中return-A，catch中return-B，finally中return-C，最终返回值是什么？" class="headerlink" title="29 try中return A，catch中return B，finally中return C，最终返回值是什么？"></a>29 try中return A，catch中return B，finally中return C，最终返回值是什么？</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(testMethod());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//System.out.print(1/0); 异常代码</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;C&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ol>
<li><strong><code>try</code> 块</strong>：<ul>
<li><code>try</code> 块中的代码首先执行，并且因为 <code>return &quot;A&quot;;</code> 语句的存在，方法会准备返回 “A”。</li>
<li>在准备返回值之前，Java会记住这个返回值，但并不会立即返回，而是继续执行 <code>finally</code> 块中的代码。</li>
</ul>
</li>
<li><strong><code>catch</code> 块</strong>：<ul>
<li>如果 <code>try</code> 块中的代码抛出了异常，那么会进入 <code>catch</code> 块。如果没有异常发生，<code>catch</code> 块就不会执行。</li>
<li>但无论 <code>catch</code> 块是否执行，<code>finally</code> 块中的代码始终会执行。</li>
</ul>
</li>
<li><strong><code>finally</code> 块</strong>：<ul>
<li><code>finally</code> 块中的代码是无论如何都会执行的。即使 <code>try</code> 或 <code>catch</code> 中有 <code>return</code> 语句，<code>finally</code> 仍然会在方法返回之前执行。</li>
<li>在 <code>finally</code> 块中，如果再次出现 <code>return</code> 语句，它会覆盖之前在 <code>try</code> 或 <code>catch</code> 中准备返回的值，并最终返回 <code>finally</code> 中的值。</li>
</ul>
</li>
</ol>
<p>总结：在try-catch-finally结构中，try和catch中的return的结果都会被暂存，检查finally后有没有return，有则会覆盖；尽量避免在 <code>finally</code> 块中使用 <code>return</code> 语句，因为这会导致代码的可读性下降和预期外的行为。</p>
<h5 id="30-finally中代码一定会执行吗？"><a href="#30-finally中代码一定会执行吗？" class="headerlink" title="30 finally中代码一定会执行吗？"></a>30 finally中代码一定会执行吗？</h5><p>大多数情况下都是会执行的，有一些特殊的情况导致finally块中的代码不执行，如下：</p>
<p>1、<strong>JVM 崩溃</strong>：如果在 <code>try</code> 或 <code>catch</code> 块执行过程中，JVM 进程突然崩溃（例如内存不足、硬件故障），<code>finally</code> 块可能不会执行。</p>
<p>2、**System.exit()**：如果在 <code>try</code> 或 <code>catch</code> 块中调用了 <code>System.exit()</code>，则 JVM 会立即终止，不会再执行 <code>finally</code> 块。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;In try block&quot;</span>);</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;In finally block&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>System.exit(0)</code> 直接终止了 JVM，导致 <code>finally</code> 块没有执行。</p>
<p>3、<strong>无限循环或死锁</strong>：如果在 <code>try</code> 块或 <code>catch</code> 块中出现了无限循环或死锁，<code>finally</code> 块可能永远不会执行，因为程序无法跳出循环或解决死锁。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// Infinite loop</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;In finally block&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，<code>finally</code> 块永远不会被执行，因为程序永远停留在无限循环中。</p>
<h5 id="31-在处理异常的时候，我们应该要注意些什么？"><a href="#31-在处理异常的时候，我们应该要注意些什么？" class="headerlink" title="31 在处理异常的时候，我们应该要注意些什么？"></a>31 在处理异常的时候，我们应该要注意些什么？</h5><p>1.<code>RuntimeException</code> 不需要显式地 <code>throws</code></p>
<p><strong>说明</strong>：<code>RuntimeException</code> 及其子类属于非受检异常（Unchecked Exception），在方法声明中不需要显式地用 <code>throws</code> 关键字抛出这些异常。</p>
<p>2.<code>catch</code> 需要先从子类进行捕获</p>
<p><strong>说明</strong>：在捕获异常时，如果有多个 <code>catch</code> 块，需要先捕获具体的子类异常，再捕获通用的父类异常，否则会导致编译错误。</p>
<p>3.始终在 <code>finally</code> 中释放资源</p>
<p><strong>说明</strong>：在使用 <code>try-catch</code> 处理异常时，如果有资源需要关闭（如文件、数据库连接等），应在 <code>finally</code> 块中释放资源，以确保即使出现异常，资源也能够得到正确的释放。</p>
<p>4.不要在 <code>finally</code> 块中使用 <code>return</code> 语句</p>
<p><strong>说明</strong>：在 <code>finally</code> 块中使用 <code>return</code> 语句会覆盖 <code>try</code> 或 <code>catch</code> 块中的 <code>return</code> 语句，从而导致不可预测的行为</p>
<p>5.只捕获你能处理的异常</p>
<p><strong>说明</strong>：不要随意捕获所有异常（如捕获 <code>Exception</code>），而应该只捕获你能够合理处理的异常。这有助于确保代码更加健壮，并且能够对错误做出合理的响应。</p>
<h5 id="32-什么是AIO、BIO和NIO？"><a href="#32-什么是AIO、BIO和NIO？" class="headerlink" title="32 什么是AIO、BIO和NIO？"></a>32 什么是AIO、BIO和NIO？</h5><p><img src="https://qinyunjian-1316017204.cos.ap-guangzhou.myqcloud.com/images/typora/1705133708567-49955e01-446a-4fef-b441-4356180eac5c.png" alt="1705133708567-49955e01-446a-4fef-b441-4356180eac5c"></p>
<p><strong>BIO (Blocking I&#x2F;O)</strong>:<br>同步阻塞 I&#x2F;O，是 JDK 1.4 之前的传统 I&#x2F;O 模型。线程发起 I&#x2F;O 请求后，会被阻塞，直到数据准备好并完成 I&#x2F;O 操作后，线程才能继续执行其他任务。每个 I&#x2F;O 请求都由一个独立线程处理，因此在高并发情况下容易造成线程资源的浪费和系统负担。</p>
<p><strong>NIO (Non-Blocking I&#x2F;O)</strong>:<br>同步非阻塞 I&#x2F;O，是 JDK 1.4 引入的 I&#x2F;O 模型。线程发起 I&#x2F;O 请求后不会阻塞，而是立即返回。用户线程可以继续处理其他任务，不必等待 I&#x2F;O 操作完成。通过轮询机制（Selector），线程可以检查 I&#x2F;O 操作是否已完成，并在数据就绪后进行处理。NIO 允许一个线程处理多个 I&#x2F;O 连接，显著提高了系统的并发处理能力。</p>
<p><strong>AIO (Asynchronous I&#x2F;O)</strong>:<br>异步非阻塞 I&#x2F;O，是 JDK 7 引入的 I&#x2F;O 模型。线程发起 I&#x2F;O 请求后立即返回，不需要阻塞，也不需要轮询检查操作结果。I&#x2F;O 操作完成后，系统会自动回调指定的处理函数（CompletionHandler），通知调用方处理结果。AIO 更加高效，适合处理大量并发连接和复杂 I&#x2F;O 操作的场景。</p>
<h5 id="33-Java是值传递还是引用传递？"><a href="#33-Java是值传递还是引用传递？" class="headerlink" title="33 Java是值传递还是引用传递？"></a>33 Java是值传递还是引用传递？</h5><p><strong>值传递和引用传递最大的区别就是传递过程中有没有复制出来一个副本，如果是传递副本，那就是值传递，否则就是引用传递。Java对象的传递，是通过复制的方式把引用关系传递了，因为有复制的过程，所以是值传递，</strong>只不过对于Java对象的传递，传递的内容是对象的引用。<strong>总的来说，Java只有值传递。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValueReferenceExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 基本数据类型</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before modifyPrimitive: a = &quot;</span> + a);</span><br><span class="line">        modifyPrimitive(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;After modifyPrimitive: a = &quot;</span> + a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象类型</span></span><br><span class="line">        <span class="type">MyObject</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();</span><br><span class="line">        obj.value = <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before modifyObject: obj.value = &quot;</span> + obj.value);</span><br><span class="line">        modifyObject(obj);</span><br><span class="line">        System.out.println(<span class="string">&quot;After modifyObject: obj.value = &quot;</span> + obj.value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象引用重新分配</span></span><br><span class="line">        resetObject(obj);</span><br><span class="line">        System.out.println(<span class="string">&quot;After resetObject: obj.value = &quot;</span> + obj.value);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 值传递，传递的是副本</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">modifyPrimitive</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        x = <span class="number">10</span>;  <span class="comment">// 仅修改了副本，不影响原始变量</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 引用传递，复制引用地址并进行传递</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">modifyObject</span><span class="params">(MyObject o)</span> &#123;</span><br><span class="line">        o.value = <span class="number">20</span>;  <span class="comment">// 修改对象属性，因为都是指向同一个对象，影响到原始对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个重新分配的引用仅在 resetObject 方法内部有效，并不影响 obj 的原始引用。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">resetObject</span><span class="params">(MyObject o)</span> &#123;</span><br><span class="line">        o = <span class="keyword">new</span> <span class="title class_">MyObject</span>();  <span class="comment">// 重新分配引用，不影响原始对象</span></span><br><span class="line">        o.value = <span class="number">30</span>;  <span class="comment">// 修改新对象的属性，原始对象不受影响</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="34-什么是深拷贝和浅拷贝？"><a href="#34-什么是深拷贝和浅拷贝？" class="headerlink" title="34 什么是深拷贝和浅拷贝？"></a>34 什么是深拷贝和浅拷贝？</h5><p><strong>浅拷贝(Shallow Copy)</strong>: 浅拷贝复制对象时，只复制对象的基本属性和对象的引用，引用对象不复制的实际内容。这意味着拷贝后的对象与原对象共享同一个引用对象的实例。</p>
<p><strong>深拷贝(Deep Copy)</strong>: 深拷贝不仅复制对象的基本属性，还复制所有引用对象的实际内容。拷贝后的对象和原对象完全独立，没有任何共享的引用。</p>
<h5 id="35-SimpleDateFormat是线程安全的吗？使用时应该注意什么？"><a href="#35-SimpleDateFormat是线程安全的吗？使用时应该注意什么？" class="headerlink" title="35 SimpleDateFormat是线程安全的吗？使用时应该注意什么？"></a>35 SimpleDateFormat是线程安全的吗？使用时应该注意什么？</h5><p><strong>答：</strong>非线程安全的，<code>SimpleDateFormat</code> 类在解析或格式化日期时会维护内部状态，比如 <code>Calendar</code> 对象，这些状态在多个线程并发访问时可能会相互干扰，导致格式化或解析的结果不正确，甚至可能抛出 <code>NumberFormatException</code> 或 <code>ArrayIndexOutOfBoundsException</code>。</p>
<p><strong>如何在多线程环境中安全地使用 <code>SimpleDateFormat</code>？</strong></p>
<p><strong>局部变量方式</strong>:</p>
<ul>
<li>每次调用 <code>formatDateWithSimpleDateFormat</code> 时，都会创建一个新的 <code>SimpleDateFormat</code> 实例，确保线程安全。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用局部变量确保线程安全</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">formatDateWithSimpleDateFormat</span><span class="params">(Date date)</span> &#123;</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> sdf.format(date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>同步块</strong>:</p>
<ul>
<li><code>formatDateWithSynchronized</code> 方法使用 <code>synchronized</code> 关键字，确保同一时刻只有一个线程可以执行格式化操作，保证线程安全。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 使用同步块确保线程安全</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleDateFormat</span> <span class="variable">sharedSdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">formatDateWithSynchronized</span><span class="params">(Date date)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sharedSdf.format(date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**使用 <code>ThreadLocal</code>**：</p>
<ul>
<li>通过 <code>ThreadLocal</code> 为每个线程创建一个 <code>SimpleDateFormat</code> 实例，这样每个线程都有自己的实例，既保证了线程安全，又避免了性能问题。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; sdf = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">formatDate</span><span class="params">(Date date)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sdf.get().format(date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用替代方案</strong>：</p>
<ul>
<li>从 Java 8 开始，<code>java.time</code> 包中的 <code>DateTimeFormatter</code> 类提供了不可变的、线程安全的日期时间格式化工具，推荐使用它代替 <code>SimpleDateFormat</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">formatDate</span><span class="params">(LocalDate date)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> date.format(formatter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="36-什么是UUID？"><a href="#36-什么是UUID？" class="headerlink" title="36 什么是UUID？"></a>36 什么是UUID？</h5><p>UUID（Universally Unique Identifier），即通用唯一标识符，是一种标准化的128位数字标识符，用于标识信息中的唯一对象。UUID 是根据特定算法生成的，可以在分布式系统中用于唯一地标识信息，无需集中管理。UUID 的主要目的是确保不同时间、不同地点生成的ID是唯一的。</p>
<h5 id="37-char能存储中文吗？"><a href="#37-char能存储中文吗？" class="headerlink" title="37 char能存储中文吗？"></a>37 char能存储中文吗？</h5><p>是的，<code>char</code> 可以存储中文字符。在Java中，<code>char</code> 数据类型是 16 位的无符号整数，使用 Unicode 编码（UTF-16）表示字符。Unicode 是一种字符编码标准，能够表示世界上几乎所有的字符集，包括中文字符。</p>
<h5 id="38-while-true-和for-那个性能好？"><a href="#38-while-true-和for-那个性能好？" class="headerlink" title="38 while(true)和for(;;)那个性能好？"></a>38 while(true)和for(;;)那个性能好？</h5><p>都一样，都是做无限循环</p>
<h5 id="39-ClassNotFoundException和NoClassDefFoundError的区别是什么？"><a href="#39-ClassNotFoundException和NoClassDefFoundError的区别是什么？" class="headerlink" title="39 ClassNotFoundException和NoClassDefFoundError的区别是什么？"></a>39 ClassNotFoundException和NoClassDefFoundError的区别是什么？</h5><ul>
<li><p><code>ClassNotFoundException</code>发生在 <strong>运行时</strong>，是一个<strong>受检异常</strong>，表示在运行时动态加载类时找不到指定的类。通常由程序的逻辑错误引发，如类名拼写错误、类路径配置不当等。</p>
</li>
<li><p><code>NoClassDefFoundError</code>也发生在 <strong>运行时</strong>，是一个<strong>错误</strong>，表示 <code>JVM</code> 在加载一个已经编译过的类时，无法找到该类。通常由运行时环境的问题引发，如类路径中缺少类、类文件损坏等。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/GXKJDX/blog/2024/08/26/Java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E8%AF%95%E9%A2%9827-39/" data-id="cm2ahnlmd000ip0u45ae7754x" data-title="三、Java基础-面试题27-39" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Java基础-面试题14-26" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/2024/08/25/Java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E8%AF%95%E9%A2%9814-26/" class="article-date">
  <time class="dt-published" datetime="2024-08-25T14:32:50.000Z" itemprop="datePublished">2024-08-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/2024/08/25/Java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E8%AF%95%E9%A2%9814-26/">二、Java基础-面试题14-26</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h5 id="14-什么是泛型，有什么好处？"><a href="#14-什么是泛型，有什么好处？" class="headerlink" title="14 什么是泛型，有什么好处？"></a>14 什么是泛型，有什么好处？</h5><p><strong>概念：</strong>在定义类、接口和方法时使用类型参数(type parameter)。这些类型参数在实例化时被具体化为实际的类型。</p>
<p><strong>好处：</strong></p>
<p><strong>类型安全</strong>：</p>
<ul>
<li>使用泛型可以在编译时检测类型错误，避免了运行时出现 <code>ClassCastException</code>。例如，使用泛型集合时，插入的元素类型必须匹配集合的类型参数。</li>
</ul>
<p><strong>消除强制类型转换</strong>：</p>
<ul>
<li>在没有泛型的代码中，获取集合中的元素需要进行强制类型转换。泛型消除了这种需求，使代码更简洁和安全。</li>
</ul>
<p><strong>无泛型的代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) list.get(<span class="number">0</span>);  <span class="comment">// 需要强制转换</span></span><br></pre></td></tr></table></figure>

<p><strong>使用泛型的代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> list.get(<span class="number">0</span>);  <span class="comment">// 不需要强制转换</span></span><br></pre></td></tr></table></figure>

<h5 id="15-什么是类型擦除？"><a href="#15-什么是类型擦除？" class="headerlink" title="15 什么是类型擦除？"></a>15 什么是类型擦除？</h5><p>在编译阶段泛型字段会被擦除，泛型类型参数在编译后被替换为它们的上界（通常是 <code>Object</code>）如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Foo</span>&lt;T&gt; &#123;</span><br><span class="line">	T bar;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">doSth</span><span class="params">(T param)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译后，等同于</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Foo</span>&lt;Object&gt; &#123;</span><br><span class="line">	Object bar;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">doSth</span><span class="params">(Object param)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="16-泛型中的KTVE？Object等分别代表什么含义？"><a href="#16-泛型中的KTVE？Object等分别代表什么含义？" class="headerlink" title="16 泛型中的KTVE？Object等分别代表什么含义？"></a>16 泛型中的KTVE？Object等分别代表什么含义？</h5><p>E - Element （在集合中使用，集合中存放的是元素）</p>
<p>T - Type （Java类，任意类型）</p>
<p>K - Key （键）</p>
<p>V - Value （值）</p>
<p>N - Number （数值类型）</p>
<p>Object - 所有类的根类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericExamples</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. E - Element: 用于集合中的元素</span></span><br><span class="line">        List&lt;String&gt; stringList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// E 被替换为 String</span></span><br><span class="line">        stringList.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">        stringList.add(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;List&lt;E&gt; example:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String element : stringList) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Element: &quot;</span> + element); <span class="comment">// 输出: Apple, Banana</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. T - Type: 通用类型参数</span></span><br><span class="line">        TypeExample&lt;Integer&gt; intType = <span class="keyword">new</span> <span class="title class_">TypeExample</span>&lt;&gt;();</span><br><span class="line">        intType.setValue(<span class="number">123</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;T - Type example:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Value: &quot;</span> + intType.getValue()); <span class="comment">// 输出: Value: 123</span></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. K - Key, V - Value: 键值对映射</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">// K 被替换为 String, V 被替换为 Integer</span></span><br><span class="line">        map.put(<span class="string">&quot;Apple&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Banana&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;K - Key, V - Value example:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Key: &quot;</span> + entry.getKey() + <span class="string">&quot;, Value: &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. N - Number: 限制为数值类型</span></span><br><span class="line">        NumberExample&lt;Double&gt; doubleExample = <span class="keyword">new</span> <span class="title class_">NumberExample</span>&lt;&gt;();</span><br><span class="line">        doubleExample.setNumber(<span class="number">3.14</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;N - Number example:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Number: &quot;</span> + doubleExample.getNumber()); <span class="comment">// 输出: Number: 3.14</span></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. Object: 所有类的根类，表示可以接受任何类型</span></span><br><span class="line">        List&lt;Object&gt; objectList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        objectList.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        objectList.add(<span class="number">456</span>);</span><br><span class="line">        objectList.add(<span class="number">78.90</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Object example:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object obj : objectList) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Object: &quot;</span> + obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// T - 通用类型参数的示例类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TypeExample</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// N - 限制为数值类型的示例类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NumberExample</span>&lt;N <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> N number;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNumber</span><span class="params">(N number)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.number = number;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> N <span class="title function_">getNumber</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>代码解释</strong></p>
<ol>
<li><strong><code>List&lt;E&gt;</code></strong> 示例：<ul>
<li><code>stringList</code> 是一个 <code>List&lt;String&gt;</code>，演示了如何使用 <code>E</code> 作为集合中的元素类型。</li>
</ul>
</li>
<li><strong><code>T</code> - Type 示例</strong>：<ul>
<li><code>TypeExample&lt;T&gt;</code> 是一个通用类型的类，展示了如何使用泛型类型参数 <code>T</code>。</li>
</ul>
</li>
<li><strong><code>K</code> - Key 和 <code>V</code> - Value 示例</strong>：<ul>
<li>使用 <code>Map&lt;K, V&gt;</code> 展示了键值对映射的用法，其中 <code>K</code> 是键的类型，<code>V</code> 是值的类型。</li>
</ul>
</li>
<li><strong><code>N</code> - Number 示例</strong>：<ul>
<li><code>NumberExample&lt;N&gt;</code> 类限制了泛型类型参数 <code>N</code> 为数值类型（如 <code>Integer</code>、<code>Double</code>），展示了如何使用泛型约束。</li>
</ul>
</li>
<li><strong><code>Object</code> 示例</strong>：<ul>
<li><code>objectList</code> 是一个 <code>List&lt;Object&gt;</code>，展示了如何存储任意类型的对象。</li>
</ul>
</li>
</ol>
<h5 id="17-泛型上下界"><a href="#17-泛型上下界" class="headerlink" title="17 泛型上下界"></a>17 泛型上下界</h5><p><strong>上界通配符 <code>&lt;? extends Number&gt;</code></strong></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Number (类)  (上界) <span class="comment">//表示可以是 `Number` 类型或其子类型，如 `Integer` 或 `Double`。</span></span><br><span class="line">   ^</span><br><span class="line">   |</span><br><span class="line">+---------+</span><br><span class="line">|         |</span><br><span class="line">Integer   Double (类)</span><br></pre></td></tr></table></figure>

<p><strong>图示解析</strong>：</p>
<ul>
<li>可以接受 <code>Number</code> 及其子类 <code>Integer</code>、<code>Double</code> 等。</li>
<li>在代码中，<code>List&lt;? extends Number&gt;</code> 可以表示 <code>List&lt;Number&gt;</code>、<code>List&lt;Integer&gt;</code> 或 <code>List&lt;Double&gt;</code>。</li>
</ul>
<p><strong>下界通配符 <code>&lt;? super Integer&gt;</code></strong></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Number   <span class="selector-tag">Object</span> (所有类的根类) <span class="comment">//表示可以是 Integer 类型或其父类型，如 Number 或 Object。</span></span><br><span class="line">    |         |</span><br><span class="line">    +---------+</span><br><span class="line">         |</span><br><span class="line">      Integer (类)  (下界)</span><br></pre></td></tr></table></figure>

<p><strong>图示解析</strong>：</p>
<ul>
<li>可以接受 <code>Integer</code> 及其父类 <code>Number</code>、<code>Object</code>。</li>
<li>在代码中，<code>List&lt;? super Integer&gt;</code> 可以表示 <code>List&lt;Integer&gt;</code>、<code>List&lt;Number&gt;</code> 或 <code>List&lt;Object&gt;</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用上界通配符，只读取数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">processNumbersExtends</span><span class="params">(List&lt;? extends Number&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Number num : list) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Number: &quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// list.add(100); // 编译错误，不能添加元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用下界通配符，写入数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">processNumbersSuper</span><span class="params">(List&lt;? <span class="built_in">super</span> Integer&gt; list)</span> &#123;</span><br><span class="line">    list.add(<span class="number">100</span>); <span class="comment">// 合法，添加 Integer 类型</span></span><br><span class="line">    <span class="comment">// Number num = list.get(0); // 编译错误，无法确定具体类型</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> list.get(<span class="number">0</span>); <span class="comment">// 合法，读取为 Object 类型</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Added: &quot;</span> + obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解析</strong>：</p>
<p><strong>上界通配符：<code>&lt;? extends Type&gt;</code></strong></p>
<ul>
<li><strong>语义</strong>：表示参数化类型的<strong>上界</strong>，即该泛型类型可以是 <code>Type</code> 本身或其任意子类。</li>
<li><strong>特性</strong>：<ul>
<li><strong>只能读取，不能写入（除了添加 <code>null</code>）</strong>：由于编译器无法确定具体的子类型，向其中添加元素可能会破坏类型安全。</li>
<li><strong>适用于提供者（Producer）角色</strong>：当你只需要从泛型对象中<strong>获取数据</strong>时，使用上界通配符。</li>
</ul>
</li>
</ul>
<p><strong>下界通配符：<code>&lt;? super Type&gt;</code></strong></p>
<ul>
<li><strong>语义</strong>：表示参数化类型的<strong>下界</strong>，即该泛型类型可以是 <code>Type</code> 本身或其任意父类。</li>
<li><strong>特性</strong>：<ul>
<li><strong>可以写入，但读取时只能作为 <code>Object</code> 类型</strong>：因为具体类型可能是 <code>Type</code> 的父类，读取元素时只能确保它至少是 <code>Object</code> 类型。</li>
<li><strong>适用于消费者（Consumer）角色</strong>：当你需要向泛型对象中<strong>写入数据</strong>时，使用下界通配符。</li>
</ul>
</li>
</ul>
<p>如果一个方法既要写入还要读取，则不要加上限定符号。</p>
<h5 id="18-什么是反射机制？为什么反射慢"><a href="#18-什么是反射机制？为什么反射慢" class="headerlink" title="18 什么是反射机制？为什么反射慢?"></a>18 什么是反射机制？为什么反射慢?</h5><p>**概念:**反射机制（Reflection）是Java语言的一种特性，它允许程序在运行时动态地获取有关类、接口、方法和字段的信息，并且可以在运行时创建对象、调用方法以及访问或修改字段。</p>
<p><strong>反射的主要功能</strong></p>
<ol>
<li><strong>获取类的 Class 对象</strong>：<ul>
<li>通过 <code>Class.forName(&quot;className&quot;)</code> 或 <code>object.getClass()</code> 获取一个类的 <code>Class</code> 对象。</li>
</ul>
</li>
<li><strong>获取类的信息</strong>：<ul>
<li>获取类的构造方法、字段、方法等信息。</li>
<li>例如，<code>Class.getDeclaredMethods()</code> 可以获取类中所有的方法。</li>
</ul>
</li>
<li><strong>实例化对象</strong>：<ul>
<li>通过反射可以动态地创建类的实例，使用 <code>Class.newInstance()</code> 或通过 <code>Constructor</code> 创建。</li>
</ul>
</li>
<li><strong>调用方法</strong>：<ul>
<li>使用 <code>Method.invoke()</code> 动态地调用对象的方法。</li>
</ul>
</li>
<li><strong>访问和修改字段</strong>：<ul>
<li>使用 <code>Field.get()</code> 和 <code>Field.set()</code> 可以在运行时访问或修改对象的字段值。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Message: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取指定类的 Class 对象</span></span><br><span class="line">            Class&lt;?&gt; clazzOne = Class.forName(<span class="string">&quot;com.qyj.subject.common.interview.basic.GenericExamples&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取指定类的所有方法</span></span><br><span class="line">            Method[] methods = clazzOne.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 输出每个方法的名字</span></span><br><span class="line">            <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;GenericExamples Method: &quot;</span> + method.getName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建ExampleClass的实例</span></span><br><span class="line">            <span class="type">ExampleClass</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExampleClass</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取ExampleClass的Class对象</span></span><br><span class="line">            Class&lt;?&gt; clazzTwo = ExampleClass.class;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用getDeclaredMethod获取特定的方法</span></span><br><span class="line">            <span class="comment">// 参数为方法名,参数类型(name,type)</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazzTwo.getDeclaredMethod(<span class="string">&quot;printMessage&quot;</span>, String.class);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 由于printMessage是私有方法，我们需要设置可访问性</span></span><br><span class="line">            method.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用获取到的方法，传递参数</span></span><br><span class="line">            method.invoke(instance, <span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取 total 字段的 Field 对象</span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazzTwo.getDeclaredField(<span class="string">&quot;total&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将字段设置为可访问</span></span><br><span class="line">            field.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取 total 字段的值</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">totalValue</span> <span class="operator">=</span> (Integer) field.get(instance);</span><br><span class="line">            System.out.println(<span class="string">&quot;Original total value: &quot;</span> + totalValue); <span class="comment">// 输出: 10</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 修改 total 字段的值</span></span><br><span class="line">            field.set(instance, <span class="number">20</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Modified total value: &quot;</span> + field.get(instance)); <span class="comment">// 输出: 20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="19-Java中创建对象有那些方式"><a href="#19-Java中创建对象有那些方式" class="headerlink" title="19 Java中创建对象有那些方式?"></a>19 Java中创建对象有那些方式?</h5><p>三种常见的创建对象的方法：使用 <code>new</code> 关键字、通过反射、以及通过反序列化。</p>
<p><strong><code>new</code> 关键字</strong>:</p>
<ul>
<li>最常见的对象创建方式。</li>
<li>编译时确定的，性能高。</li>
</ul>
<p><strong>反射</strong>:</p>
<ul>
<li>允许在运行时动态创建对象。</li>
<li>更灵活，但性能较低，且需要处理可能的异常。</li>
</ul>
<p><strong>反序列化</strong>:</p>
<ul>
<li>通过将字节流转换回对象来创建对象。</li>
<li>不调用构造器，直接恢复对象的状态，适用于分布式系统或持久化场景。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectCreationExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 使用new关键字创建对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUsingNew</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Example</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Example</span>(<span class="string">&quot;Hello from new!&quot;</span>);</span><br><span class="line">        example.printMessage(); <span class="comment">// 输出: Hello from new!</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 使用反射创建对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUsingReflection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取Example类的Class对象</span></span><br><span class="line">            Class&lt;?&gt; clazz = Example.class;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取构造器</span></span><br><span class="line">            Constructor&lt;?&gt; constructor = clazz.getConstructor(String.class);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用构造器通过反射创建对象</span></span><br><span class="line">            <span class="type">Example</span> <span class="variable">example</span> <span class="operator">=</span> (Example) constructor.newInstance(<span class="string">&quot;Hello via Reflection!&quot;</span>);</span><br><span class="line">            example.printMessage(); <span class="comment">// 输出: Hello via Reflection!</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 使用反序列化创建对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUsingDeserialization</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 序列化：将对象写入文件</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;example.ser&quot;</span>))) &#123;</span><br><span class="line">            <span class="type">Example</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Example</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">            out.writeObject(example); <span class="comment">// 将对象写入文件</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化：从文件中读取对象</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;example.ser&quot;</span>))) &#123;</span><br><span class="line">            <span class="type">Example</span> <span class="variable">example</span> <span class="operator">=</span> (Example) in.readObject(); <span class="comment">// 通过反序列化创建对象</span></span><br><span class="line">            example.printMessage(); <span class="comment">// 输出: Hello, World!</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ObjectCreationExample</span> <span class="variable">objectCreationExample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectCreationExample</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用new关键字创建对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Creating object using new keyword:&quot;</span>);</span><br><span class="line">        objectCreationExample.createUsingNew();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\nCreating object using reflection:&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用反射创建对象</span></span><br><span class="line">        objectCreationExample.createUsingReflection();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\nCreating object using deserialization:&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用反序列化创建对象</span></span><br><span class="line">        objectCreationExample.createUsingDeserialization();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例类，支持序列化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Example</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="20-序列化与反序列化"><a href="#20-序列化与反序列化" class="headerlink" title="20 序列化与反序列化"></a>20 序列化与反序列化</h5><p>20.1 **序列化:**是将一个对象的状态转换成字节流过程, <strong>反序列化</strong>：是将字节流转换回原始对象的过程。</p>
<ul>
<li><p><strong>序列化：</strong>对象 -&gt; 字节流</p>
</li>
<li><p><strong>反序列化：</strong>字节流 -&gt; 对象</p>
</li>
</ul>
<p>20.2 <strong>用途(为什么要使用序列化?)：</strong>序列化是将对象转换成可传输的格式的过程，是一种数据传输手段，广泛应用于网络传输，RMI和RPC，数据存储和持久化等应用场景。</p>
<p>20.3 <strong>重点知识：</strong></p>
<ul>
<li><p>如果一个类想被序列化，则需要实现Serializable接口。</p>
</li>
<li><p>通过<code>ObjectOutputStream</code>和<code>ObjectInputStream</code>对对象进行序列化与反序列化，如上述的代码所示。</p>
</li>
<li><p>序列化不能保存静态变量</p>
</li>
<li><p><code>transient</code> 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件，在被反序列化后，<code>transient</code> 变量的值被设为初始值，如 <code>int</code> 型的是 0，对象型的是 <code>null</code>。</p>
</li>
</ul>
<h5 id="21-序列化的实现原理"><a href="#21-序列化的实现原理" class="headerlink" title="21 序列化的实现原理"></a>21 序列化的实现原理</h5><p><strong>序列化的基本原理</strong></p>
<ol>
<li><strong><code>Serializable</code> 接口</strong>：<ul>
<li>在Java中，一个类要实现序列化，必须实现 <code>Serializable</code> 接口。<code>Serializable</code> 是一个标记接口，意味着它没有任何方法，仅作为一个标记，表示该类的实例可以被序列化。</li>
<li>实现了 <code>Serializable</code> 接口的类的实例可以被序列化为字节流，然后再反序列化为对象。</li>
</ul>
</li>
<li><strong>序列化过程</strong>：<ul>
<li>序列化的过程是将对象的状态转化为字节流。这个过程由 <code>ObjectOutputStream</code> 类的 <code>writeObject()</code> 方法完成。</li>
<li><code>ObjectOutputStream</code> 会遍历对象的所有字段，并将它们的值写入输出流中。如果某个字段本身是对象引用，那么该对象也会被递归序列化。</li>
<li>类的元数据（例如类的名称、版本号等）以及对象的类型信息（例如对象属于哪个类）也会被写入字节流。</li>
</ul>
</li>
<li><strong>反序列化过程</strong>：<ul>
<li>反序列化的过程是将字节流恢复为原始的对象。这个过程由 <code>ObjectInputStream</code> 类的 <code>readObject()</code> 方法完成。</li>
<li><code>ObjectInputStream</code> 通过读取字节流中的类的元数据和字段数据，重新构造对象的实例。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. 使用反序列化创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUsingDeserialization</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 序列化：将对象写入文件</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;example.ser&quot;</span>))) &#123;</span><br><span class="line">        <span class="type">Example</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Example</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">        out.writeObject(example); <span class="comment">// 将对象写入文件</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化：从文件中读取对象</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;example.ser&quot;</span>))) &#123;</span><br><span class="line">        <span class="type">Example</span> <span class="variable">example</span> <span class="operator">=</span> (Example) in.readObject(); <span class="comment">// 通过反序列化创建对象</span></span><br><span class="line">        example.printMessage(); <span class="comment">// 输出: Hello, World!</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="22-Serializable和Externalizable接口有什么不同？"><a href="#22-Serializable和Externalizable接口有什么不同？" class="headerlink" title="22 Serializable和Externalizable接口有什么不同？"></a>22 Serializable和Externalizable接口有什么不同？</h5><p><strong>实现方式：</strong></p>
<ul>
<li><p>通过 <code>Serializable</code> 接口，Java 可以自动处理对象的序列化和反序列化过程，无需开发者干预。</p>
</li>
<li><p>通过 <code>Externalizable</code> 接口，开发者可以完全控制序列化和反序列化过程，手动实现 <code>writeExternal</code> 和 <code>readExternal</code> 方法。</p>
</li>
</ul>
<p><strong>无参构造器</strong>:</p>
<ul>
<li>当使用 <code>Externalizable</code> 接口时，反序列化过程中需要使用无参构造器来创建对象实例，因此必须提供一个无参构造器。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>; <span class="comment">// 用于 Serializable 接口的版本控制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须提供一个无参构造器，供 Externalizable 使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>writeExternal</code> 和 <code>readExternal</code> 方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 手动控制序列化过程，只写入需要序列化的字段</span></span><br><span class="line">    out.writeUTF(name);</span><br><span class="line">    out.writeInt(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 手动控制反序列化过程，按顺序读取字段并恢复对象状态</span></span><br><span class="line">    <span class="built_in">this</span>.name = in.readUTF();</span><br><span class="line">    <span class="built_in">this</span>.age = in.readInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="23-serialVersionUID-有何用途-如果没定义会有什么问题？"><a href="#23-serialVersionUID-有何用途-如果没定义会有什么问题？" class="headerlink" title="23 serialVersionUID 有何用途? 如果没定义会有什么问题？"></a>23 <code>serialVersionUID</code> 有何用途? 如果没定义会有什么问题？</h5><p>23.1 <strong>用途：</strong><code>serialVersionUID</code> 是一个独特的标识符，用于表示类的序列化版本。它是 <code>Serializable</code> 接口的一部分，用来确保在反序列化时，类的版本与序列化时的版本保持一致。</p>
<p>23.2 如果未定义 <code>serialVersionUID：</code>Java 将自动生成，但这会带来版本控制上的不确定性，可能导致 <code>InvalidClassException</code> 异常，尤其在类结构发生变化时。</p>
<p>23.2 <code>serialVersionUlD</code>有两种显示的生成方式:是默认的1L，比如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span><span class="number">1L</span>;</span><br></pre></td></tr></table></figure>

<p>二是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段，比如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUlD</span> <span class="operator">=</span> xxxxL;</span><br></pre></td></tr></table></figure>

<h5 id="24-Java的动态代理是什么？如何实现？"><a href="#24-Java的动态代理是什么？如何实现？" class="headerlink" title="24 Java的动态代理是什么？如何实现？"></a>24 Java的动态代理是什么？如何实现？</h5><p><strong>概念：</strong>动态代理是Java 一大特性。 它的显著优势就是无侵入式的扩展代码。 通俗来讲就是<strong>可以用来做方法的增强，让你可以在不修改源码的情况下，增强一些方法或者功能，在方法执行前后做任何你想做的事情</strong>。 具体应用的话，比如可以添加调用日志，做事务控制等。</p>
<p><strong>如何实现：</strong></p>
<p>1、<code>JDK</code>动态代理：<code>Java.lang.reflect</code>包中的Proxy类和InvocationHandler接口提供了生成动态代理类的能力。</p>
<p>2、<code>Cglib</code>动态代理：<code>Cglib(Code Generation Library)</code>是一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。</p>
<p><strong>JDK动态代理</strong></p>
<p><strong>步骤：</strong></p>
<ol>
<li><strong>定义接口</strong>：目标类必须实现的接口。</li>
<li><strong>实现接口的目标类</strong>：实现业务逻辑。</li>
<li>**创建<code>InvocationHandler</code>**：实现 <code>InvocationHandler</code> 接口，编写代理逻辑。</li>
<li><strong>使用<code>Proxy</code>创建代理对象</strong>：通过 <code>Proxy.newProxyInstance</code> 方法创建代理对象。</li>
</ol>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义接口 定义了目标类需要实现的方法 perform()</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">perform</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 实现接口的目标类 实现了 Service 接口的 perform 方法，这是需要代理的目标对象。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealService</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">perform</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RealService: Performing the service.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建InvocationHandler</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServiceInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before method: &quot;</span> + method.getName()); <span class="comment">//方法执行前</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args); <span class="comment">//方法执行中</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After method: &quot;</span> + method.getName()); <span class="comment">//方法执行后</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxyExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 4. 使用Proxy创建代理对象</span></span><br><span class="line">        <span class="comment">// Proxy.newProxyInstance(</span></span><br><span class="line">	<span class="comment">// 类加载器：加载代理类的字节码。</span></span><br><span class="line">	<span class="comment">// 接口数组：指定代理对象要实现的接口。</span></span><br><span class="line">	<span class="comment">// InvocationHandler：定义代理对象如何处理方法调用。)</span></span><br><span class="line">        <span class="type">RealService</span> <span class="variable">realService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealService</span>();<span class="comment">//实例化目标对象</span></span><br><span class="line">        <span class="type">Service</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (Service) Proxy.newProxyInstance(</span><br><span class="line">                realService.getClass().getClassLoader(),</span><br><span class="line">                realService.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ServiceInvocationHandler</span>(realService)</span><br><span class="line">        );<span class="comment">// 创建目标对象的代理对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用代理对象的方法</span></span><br><span class="line">        proxyInstance.perform();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="25-静态代理和动态代理的区别"><a href="#25-静态代理和动态代理的区别" class="headerlink" title="25 静态代理和动态代理的区别"></a>25 静态代理和动态代理的区别</h5><p>静态代理就是编译期要确定的，动态代理是运行期间确定的</p>
<h5 id="26-什么是元注解"><a href="#26-什么是元注解" class="headerlink" title="26 什么是元注解"></a>26 什么是元注解</h5><p><strong>概念：</strong>定义其他注解的注解，通过元注解产生其他注解，如@Override就是通过元注解定义出来的</p>
<p>元注解有四个：@Target(表示该注解可以用在什么地方)、@Retention(表示在什么级别保存该注解信息)、@Documented(将此注解包含在javadoc中)、@Inherited(允许子类继承父类中的注解)</p>
<p><strong>怎么定义一个注解？</strong></p>
<p>在Java中，自定义注解通常使用<code>@interface</code>来定义，常见格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> 注解名称 &#123;</span><br><span class="line">    <span class="comment">// 注解的属性 (默认值)</span></span><br><span class="line">    数据类型 属性名();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@Target 表示我们的注解可以用在哪些地方？</strong></p>
<p>@Target(ElementType.TYPE)——接口、类、枚举、注解<br>@Target(ElementType.FIELD)——字段、枚举的常量<br>@Target(ElementType.METHOD)——方法<br>@Target(ElementType.PARAMETER)——方法参数<br>@Target(ElementType.CONSTRUCTOR) ——构造函数<br>@Target(ElementType.LOCAL_VARIABLE)——局部变量<br>@Target(ElementType.ANNOTATION_TYPE)——注解<br>@Target(ElementType.PACKAGE)——包</p>
<p><strong>@Retention 表示我们的注解在什么地方还有效？</strong></p>
<p>1、RetentionPolicy.SOURCE：注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃；<br>2、RetentionPolicy.CLASS：注解被保留到class文件，但jvm加载class文件时候被遗弃，这是默认的生命周期；<br>3、RetentionPolicy.RUNTIME：注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在；<br>这3个生命周期分别对应于：Java源文件(.java文件) —&gt; .class文件 —&gt; 内存中的字节码<strong>。</strong></p>
<p><strong>@Documented 表示是否将我们的注解生成在javadoc中</strong></p>
<p><strong>@Inherited 表示子类可以继承父类的注解</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/GXKJDX/blog/2024/08/25/Java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E8%AF%95%E9%A2%9814-26/" data-id="cm2ahnlmc000fp0u47a26cf6b" data-title="二、Java基础-面试题14-26" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Java基础-面试题1-13" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/2024/08/24/Java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E8%AF%95%E9%A2%981-13/" class="article-date">
  <time class="dt-published" datetime="2024-08-24T14:32:50.000Z" itemprop="datePublished">2024-08-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/2024/08/24/Java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E8%AF%95%E9%A2%981-13/">一、Java基础-面试题1-13</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h5 id="1-Java和C-的区别？"><a href="#1-Java和C-的区别？" class="headerlink" title="1 Java和C++的区别？"></a>1 Java和C++的区别？</h5><p>C++是编译型语言，Java是解释型语言。</p>
<h5 id="2-如何理解面向过程和面向对象？"><a href="#2-如何理解面向过程和面向对象？" class="headerlink" title="2 如何理解面向过程和面向对象？"></a>2 如何理解面向过程和面向对象？</h5><p>2.1面向过程把问题分解成每一步骤，每一个步骤用函数实现，面向对象把步骤分解，步骤抽象，形成对象，通过对象的调用解决问题。</p>
<p>2.2面向对象的三大特点</p>
<ul>
<li><p><strong>封装</strong>：抽象成一个具体的Java类</p>
</li>
<li><p><strong>继承</strong>：子类继承父类（基类）的方法，方便方法复用</p>
</li>
<li><p><strong>多态</strong>：<code>override</code>运行时多态 <code>overload</code>编译时多态</p>
</li>
</ul>
<h5 id="3接口和抽象类的区别？"><a href="#3接口和抽象类的区别？" class="headerlink" title="3接口和抽象类的区别？"></a>3接口和抽象类的区别？</h5><ul>
<li><p>抽象类可以有构造器，接口不能有构造器，抽象类和接口都不能被实例化。</p>
</li>
<li><p>接口可以被实现，抽象类可以被继承。</p>
</li>
<li><p>一个类可以实现多个接口，但是只能继承一个抽象类，接口支持多重继承。</p>
</li>
</ul>
<p>抽象类示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AnimalTwo</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法，子类必须实现</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AnimalTwo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am father&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 抽象类中的具体方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">breathe</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Breathing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DogTwo</span> <span class="keyword">extends</span> <span class="title class_">AnimalTwo</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bark!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DogTwo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;I am son&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        AnimalTwo animalTwo = new AnimalTwo(); 抽象类不能被实例化</span></span><br><span class="line">        <span class="type">DogTwo</span> <span class="variable">dogTwo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DogTwo</span>();</span><br><span class="line">        dogTwo.makeSound();  <span class="comment">// 输出：Bark!</span></span><br><span class="line">        dogTwo.breathe();    <span class="comment">// 输出：Breathing...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能这样做：</span></span><br><span class="line"><span class="comment">// Flyable flyable = new Flyable(); // 编译错误，因为接口不能被实例化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样是可以的：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bird is flying&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Flyable</span> <span class="variable">flyable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>(); <span class="comment">// 使用实现了接口的类来实例化</span></span><br><span class="line">        flyable.fly(); <span class="comment">// 输出：Bird is flying</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-Java中已经有了基本数据类型，为什么还需要包装类？"><a href="#4-Java中已经有了基本数据类型，为什么还需要包装类？" class="headerlink" title="4 Java中已经有了基本数据类型，为什么还需要包装类？"></a>4 Java中已经有了基本数据类型，为什么还需要包装类？</h5><p>4.1区别：</p>
<ul>
<li>基本类型默认值为0，false或\u0000等，包装类为null。</li>
<li>基本直接使用，不需要new，包装需要new。</li>
</ul>
<p>4.2自动拆箱和装箱</p>
<ul>
<li>自动拆箱：包装类转成基本数据类型；自动装箱：基本数据类型转换成包装类。</li>
</ul>
<p>4.3自动拆箱和装箱应用场景：包装类型和基本类型比较大小，包装类型的运算等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoBoxingUnboxingExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在 c == d 的比较中，c 和 d 是 Integer 对象，因此它们的引用地址不同，因为它们的值超过了 Java 的整数缓存范围（-128 到 127）。</span></span><br><span class="line"><span class="comment">        如果 c 和 d 在这个范围内，== 比较结果为 true，因为 Java 对这些值进行了缓存。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基本类型</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 包装类型</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较基本类型和包装类型</span></span><br><span class="line">        <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;a 和 b 相等 (自动拆箱)&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;a 和 b 不相等&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较两个包装类型</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c == d) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;c 和 d 引用相同&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;c 和 d 引用不同&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 equals() 方法比较两个包装类型的值</span></span><br><span class="line">        <span class="keyword">if</span> (c.equals(d)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;c 和 d 的值相等&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;c 和 d 的值不相等&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基本类型和包装类型的运算</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> a + b; <span class="comment">// b 自动拆箱为 int 类型</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a + b = &quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-为什么不能用float-double表示金额？"><a href="#5-为什么不能用float-double表示金额？" class="headerlink" title="5 为什么不能用float,double表示金额？"></a>5 为什么不能用float,double表示金额？</h5><p>避免造成精度丢失，<code>Java</code>提供了<code>BigDecimal</code>来进行精确计算。</p>
<h5 id="6-为什么不能用BigDecimal中的equals方法来做值比较？"><a href="#6-为什么不能用BigDecimal中的equals方法来做值比较？" class="headerlink" title="6 为什么不能用BigDecimal中的equals方法来做值比较？"></a>6 为什么不能用BigDecimal中的equals方法来做值比较？</h5><p>因为使用<code>BigDecimal</code>中的<code>equals</code>方法会比较值和标度，如比较0.1和0.10，他们的值虽然是一样的，但是精度是不一样的。通常使用<code>compareTo</code>进行值的比较。</p>
<h5 id="7-BigDecimal-double-和BigDecimal-String-有什么区别？"><a href="#7-BigDecimal-double-和BigDecimal-String-有什么区别？" class="headerlink" title="7 BigDecimal(double)和BigDecimal(String)有什么区别？"></a>7 BigDecimal(double)和BigDecimal(String)有什么区别？</h5><p><code>BigDecimal(double)</code>创建出的值并不是准确的数字，而是一个近似值，而使用<code>BigDecimal(String)</code>所创建出的值就等于其本身。</p>
<p>如：<code>new BigDecimal(0.1)</code>所创建出的值并不等于0.1，而<code>BigDecimal(&quot;0.1&quot;)</code>创建出的值正好等于0.1。</p>
<h5 id="8-String、StringBuilder、StringBuffer的区别？"><a href="#8-String、StringBuilder、StringBuffer的区别？" class="headerlink" title="8 String、StringBuilder、StringBuffer的区别？"></a>8 String、StringBuilder、StringBuffer的区别？</h5><p>8.1 <code>String</code>类被声明为<code>final</code>，<code>final</code>修饰的类是不能被继承的，所以<code>String</code>类中的方法无法被重写。</p>
<p>8.2 <code> String</code>类没有提供用于修改字符串内容的方法，任何对字符串的修改，都会产生一个新的<code>String</code>对象。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span></span><br><span class="line">s = s.concat(<span class="string">&quot;ef&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>虽然字符串内容看似已经成功修改，但是实际上s已经创建了一个新的对象了。</p>
<p><img src="https://qinyunjian-1316017204.cos.ap-guangzhou.myqcloud.com/images/typora/1693569145559-1464948e-b069-4234-8f03-40dba93f044b.jpeg"></p>
<p>所以当需要创建可变的字符串对象时，通常使用<code>StringBuilder</code>或<code>StringBuffer</code>。</p>
<p>8.3 String的”+”是如何实现的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1 + <span class="string">&quot;,&quot;</span> + s2 <span class="comment">//等同于(new StringBuilder()).append(s1).append(&quot;,&quot;).append(s2).toString()</span></span><br></pre></td></tr></table></figure>

<p>使用<code>+</code>进行字符拼接，实际上是通过<code>StringBuilder</code>的<code>append</code>方法进行处理的。</p>
<p>8.4 为什么不要再循环中频繁的使用字符串拼接，而是使用<code>StringBuffer</code>和<code>StringBuilder</code>进行替代</p>
<p>因为每次循坏都会创建临时对象，造成性能下降和内存浪费，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    result += i;  <span class="comment">//等同于(new StringBuilder()).append(result).append(i).toString()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9-String为什么设计成不可变的？"><a href="#9-String为什么设计成不可变的？" class="headerlink" title="9 String为什么设计成不可变的？"></a>9 String为什么设计成不可变的？</h5><p>可以从缓存，安全性，线程安全等角度进行解释。</p>
<p>9.1 <strong>缓存</strong>：<code>Java</code>中会存在一个字符串常量池，当创建对象时，常量池会先检查是否已经存在改对象，如已经存在则指向同一对象，如不存在则创建新的对象，这种机制依赖于<code>String</code>的不可变性。</p>
<p>9.2 <strong>安全性</strong>：在实际应用中，用户密钥，文件路径等敏感信息都是用<code>String</code>类来进行存储的，如果<code>String</code>类是可变的，在某些情况下内容会被恶意篡改，从而引发安全性问题。</p>
<p>9.3 <strong>线程安全</strong>：不可变对象在多个线程之间共享，它们的线程是安全的，当某个线程更改了值，会在字符串常量池中创建一个新的字符串，而不是修改相同的值，因此，字符串对于多线程来说是安全的。</p>
<h5 id="10-String-str-new-String-hollis-创建了几个对象？"><a href="#10-String-str-new-String-hollis-创建了几个对象？" class="headerlink" title="10 String str&#x3D;new String(hollis)创建了几个对象？"></a>10 String str&#x3D;new String(hollis)创建了几个对象？</h5><p>通常情况下，这行代码会创建两个对象，</p>
<ol>
<li><strong>字符串常量池中的对象</strong>：<ul>
<li><code>hollis</code> 是一个字符串字面量。在代码执行时，Java 会检查字符串常量池中是否已经存在内容为 <code>hollis</code> 的字符串对象。如果不存在，Java 会在字符串常量池中创建一个新的 <code>hollis</code> 字符串对象。</li>
<li>如果常量池中已经存在 <code>hollis</code>，则不会创建新的对象。</li>
</ul>
</li>
<li><strong>堆中的 <code>String</code> 对象</strong>：<ul>
<li><code>new String(hollis)</code> 明确表示创建一个新的 <code>String</code> 对象，即使 <code>hollis</code> 已经存在于字符串常量池中。这个新的 <code>String</code> 对象会存储在堆（heap）中，并且它的内容会是指向常量池中 <code>hollis</code> 的引用。</li>
<li>这个 <code>String</code> 对象是通过 <code>new</code> 关键字创建的，因此在每次执行这行代码时都会生成一个新的对象。</li>
</ul>
</li>
</ol>
<p><strong>结论</strong>：</p>
<ul>
<li>如果 <code>hollis</code> 字符串字面量在常量池中不存在，那么 <code>String str = new String(hollis);</code> 这行代码会创建两个对象：一个在字符串常量池中，一个在堆中。</li>
<li>如果 <code>hollis</code> 字符串字面量已经在常量池中存在，那么这行代码只会创建一个对象，即堆中的 <code>String</code> 对象。</li>
</ul>
<p>总结： <strong>通常情况下，这行代码会创建两个对象</strong>，一个在常量池中（如果字面量 <code>hollis</code> 还不存在），一个在堆中（无论如何都会创建）。</p>
<h5 id="11-String-a-“ab”-String-b-“a”-“b”-a-b-吗？"><a href="#11-String-a-“ab”-String-b-“a”-“b”-a-b-吗？" class="headerlink" title="11 String a &#x3D; “ab”; String b &#x3D; “a” + “b”; a &#x3D;&#x3D; b 吗？"></a>11 String a &#x3D; “ab”; String b &#x3D; “a” + “b”; a &#x3D;&#x3D; b 吗？</h5><p>结果为<code>true</code>，因为&#x3D;&#x3D;比较的是对象的引用，因为a和b都是<strong>字面量</strong>组成的字符串，引用地址在编译的时候已经确定了，在编译时，会把字面量直接拼接在一起，所以二者都是引用同一个对象。</p>
<p><strong>字面量</strong>：说简单点，字面量就是指有数字、字母等构成的字符串或数值，字面量只能以右值出现，即右值等于左边的值，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hollis&quot;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="12-RPC接口返回中，使用基本类型还是包装类？"><a href="#12-RPC接口返回中，使用基本类型还是包装类？" class="headerlink" title="12 RPC接口返回中，使用基本类型还是包装类？"></a>12 RPC接口返回中，使用基本类型还是包装类？</h5><p>尽量使用包装类，因为基本数据类型在发生异常的时候可能会返回默认值，如<code>int</code> 默认返回0，而包装类则会返回<code>null</code>。</p>
<h5 id="13-在开发过程中常见的语法糖？"><a href="#13-在开发过程中常见的语法糖？" class="headerlink" title="13 在开发过程中常见的语法糖？"></a>13 在开发过程中常见的语法糖？</h5><p>所谓语法糖就是方便开发人员使用，对语法进行简化；但在编译的时候会还原成最基础的语法，这个就是解语法糖。</p>
<p>13.1 <strong><code>switch</code>支持使用<code>String</code>类</strong></p>
<p><code>Java</code>中的<code>switch</code>原本就是支持基本类型，比如<code>int</code>、<code>char</code>等，对于<code>int</code>类型，会直接比较数值，对于<code>char</code>，则会比较ASCII码。对于编译器来说，</p>
<p>任何类型的比较都要转成整型。如<code>short</code>、<code>char</code>（ASCII码是整型）、以及<code>int</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (str) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;world&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际在编译器中的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span><span class="string">&quot;world&quot;</span>;</span><br><span class="line">String s;</span><br><span class="line"><span class="keyword">switch</span>((s=str).hashcode()) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">99162322</span>:</span><br><span class="line">		<span class="keyword">if</span>(s.equals(<span class="string">&quot;hello”))</span></span><br><span class="line"><span class="string">			System.out.println(&quot;</span>hello<span class="string">&quot;);</span></span><br><span class="line"><span class="string">		break;</span></span><br><span class="line"><span class="string">	case 113318802:</span></span><br><span class="line"><span class="string">		if(s.equals(&quot;</span>world<span class="string">&quot;))</span></span><br><span class="line"><span class="string">			System.out.println(&quot;</span>world<span class="string">&quot;);</span></span><br><span class="line"><span class="string">		break;</span></span><br><span class="line"><span class="string">	default:</span></span><br><span class="line"><span class="string">		break;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>字符串的<code>switch</code>是通过<code>equals()</code>和<code>hasdCode()</code>方法来实现的</p>
<p>13.2 <strong>泛型</strong></p>
<p>13.2.1 <strong>定义</strong>：泛型允许类、接口、和方法在定义的时候使用类型参数，这能使代码更加通用和类型安全。</p>
<p><strong>类</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T item;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setItem</span><span class="params">(T item)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getItem</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，<code>Box</code> 类是一个泛型类，<code>T</code> 是一个类型参数，可以在创建 <code>Box</code> 对象时指定具体的类型。</p>
<p><strong>接口</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceName</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 在接口中使用类型参数T</span></span><br><span class="line">    T <span class="title function_">Method</span><span class="params">(T param)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法</strong>：方法也可以是泛型的，即方法定义中可以有一个或多个类型参数。这使得方法能够处理不同类型的对象，而不需要定义多个重载方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(T[] array)</span> &#123; <span class="comment">// 方法声明使用了泛型类型（如 T）</span></span><br><span class="line">    <span class="keyword">for</span> (T element : array) &#123;</span><br><span class="line">        System.out.println(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果去掉方法中的<code>&lt;T&gt;</code>，则编译器会报警：Cannot resolve symbol ‘T’，这意味着编译器不知道<code>T</code>是什么类型。</p>
<p>13.2.2 <strong>泛型的边界</strong>：对泛型类型参数进行约束，比如要求类型参数必须是某个类的子类或实现某个接口。这可以通过使用 <code>extends</code> 关键字来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="keyword">void</span> <span class="title function_">printNumber</span><span class="params">(T number)</span> &#123;</span><br><span class="line">    System.out.println(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中，<code>T</code> 必须是 <code>Number</code> 的子类或 <code>Number</code> 本身。这样就限制了 <code>printNumber</code> 方法只能接受数字类型的参数</p>
<p>13.2.3 <strong>通配符</strong>：</p>
<p>在泛型中，通配符用于表示未知类型。常见的通配符有两种：</p>
<ul>
<li><strong>无界通配符（?）</strong>：可以接受任何类型。</li>
<li><strong>有界通配符</strong>：<ul>
<li>**<code>? extends T</code>**：表示可以接受 <code>T</code> 类型及其子类型。</li>
<li>**<code>? super T</code>**：表示可以接受 <code>T</code> 类型及其父类型。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processElements</span><span class="params">(List&lt;? extends Number&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Number number : list) &#123;</span><br><span class="line">        System.out.println(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中，<code>List&lt;? extends Number&gt;</code> 表示可以接受一个 <code>Number</code> 或 <code>Number</code> 的子类的列表。</p>
<p>13.2.4 <strong>类型擦除</strong></p>
<p>泛型在编译时被擦除，实际上运行时并不保留类型信息。例如，<code>List&lt;String&gt;</code> 在运行时就是 <code>List</code>。</p>
<p>13.3 <strong>自动拆箱与装箱</strong></p>
<p><strong>自动装箱</strong>：原始类型转换成对应的对象，如int变量转换成Integer对象。</p>
<p><strong>自动拆箱</strong>：对应的对象转成成原始类型，Integer对象转换成int类型值。</p>
<p>原始类型byte,short,char,int,long,float,double,boolean 对应的封装类为Byte,Short,Character,Integer,Long,Float,Double,Boolean。装箱过程是通过调用包装器的<code>valueOf</code>方法实现的，而拆箱过程则是调用包装器的<code>xxxValue</code>方法实现的，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">// 自动装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;       <span class="comment">// 自动拆箱</span></span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>);  <span class="comment">// 自动装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i.intValue();             <span class="comment">// 自动拆箱</span></span><br></pre></td></tr></table></figure>

<p>13.4 <strong>枚举</strong></p>
<p>枚举是一种特殊的数据类型，用于表示有限的一组常量。当我们使用<code>enum</code>来定义一个枚举类型的时候，编译器会自动帮我们创建一个<code>final</code>类型的类继承<code>enum</code>类，所以枚举类型不能被继承。</p>
<p>13.5 <strong>for-each</strong></p>
<p>for-each的实现原理其实就是使用了普通的for循环和迭代器，迭代器示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 ArrayList 并添加一些元素</span></span><br><span class="line">    ArrayList&lt;String&gt; fruits = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    fruits.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">    fruits.add(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">    fruits.add(<span class="string">&quot;Cherry&quot;</span>);</span><br><span class="line">    fruits.add(<span class="string">&quot;Date&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取该 ArrayList 的迭代器</span></span><br><span class="line">    Iterator&lt;String&gt; iterator = fruits.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用迭代器遍历集合</span></span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) <span class="comment">//检查集合是否存在下一元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fruit</span> <span class="operator">=</span> iterator.next();<span class="comment">//获取当前元素</span></span><br><span class="line">        System.out.println(fruit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>迭代器的特点</strong></p>
<ul>
<li><strong>顺序访问</strong>：<code>Iterator</code> 提供了一种顺序访问集合元素的方式。</li>
<li><strong>移除元素</strong>：<code>Iterator</code> 还提供了 <code>remove()</code> 方法，可以在遍历时移除当前元素，但需要注意，它只能在调用 <code>next()</code> 之后调用，且只能移除当前遍历的元素</li>
</ul>
<p>13.6 <strong>try-with-resource</strong></p>
<p>基本语法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">ResourceType</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceType</span>()) &#123;</span><br><span class="line">    <span class="comment">// 使用资源</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType e) &#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>ResourceType</strong>: 资源的类型，它必须实现 <code>AutoCloseable</code> 接口。</p>
</li>
<li><p><strong>resource</strong>: 声明并初始化要使用的资源。</p>
</li>
<li><p><strong>try 块</strong>: 在此块中使用资源，资源在此块结束时自动关闭。</p>
</li>
<li><p><strong>catch 块</strong>: 用于处理可能出现的异常。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/GXKJDX/blog/2024/08/24/Java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E8%AF%95%E9%A2%981-13/" data-id="cm2ahnlma0008p0u43xv8cap3" data-title="一、Java基础-面试题1-13" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-MySQL 常用知识点" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/2024/07/31/MySQL%20%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time class="dt-published" datetime="2024-07-31T14:32:50.000Z" itemprop="datePublished">2024-07-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/2024/07/31/MySQL%20%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9/">一、常用的 MySQL 命令示例</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一、常用的-MySQL-命令示例"><a href="#一、常用的-MySQL-命令示例" class="headerlink" title="一、常用的 MySQL 命令示例"></a>一、常用的 MySQL 命令示例</h3><ol>
<li><p><strong>SELECT</strong> 用于查询数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> users;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>WHERE</strong> 查询数据时给定条件筛选</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">&gt;=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>DISTINCT</strong> 去掉重复值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> name <span class="keyword">FROM</span> users;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>AND, OR, NOT</strong> 逻辑操作符</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">&gt;=</span> <span class="number">1</span> <span class="keyword">AND</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>IN</strong> 查询多个数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>BETWEEN</strong> 查询某个范围的数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>LIKE</strong> 模糊查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;A%&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>REGEXP</strong> 通过正则表达式查找记录</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name REGEXP <span class="string">&#x27;A.*&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>GROUP BY</strong> 结果集分组</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> item_name, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> total <span class="keyword">FROM</span> orders <span class="keyword">GROUP</span> <span class="keyword">BY</span> item_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ORDER BY</strong> 排序结果集</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">ORDER</span> <span class="keyword">BY</span> id;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>LIMIT</strong> 限定返回记录条数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>JOIN</strong> 连接查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> users.name, orders.item_name </span><br><span class="line"><span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> users.id <span class="operator">=</span> orders.user_id;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="二、连表操作示例"><a href="#二、连表操作示例" class="headerlink" title="二、连表操作示例"></a>二、连表操作示例</h3><ol>
<li><strong>INNER JOIN</strong> 连接用户表和订单表，显示所有用户及其订单。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> users.name, orders.item_name, orders.price </span><br><span class="line"><span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> users.id <span class="operator">=</span> orders.user_id;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>LEFT JOIN</strong> 连接用户表和订单表，显示所有用户及其订单（包括没有订单的用户）。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> users.name, orders.item_name, orders.price </span><br><span class="line"><span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> users.id <span class="operator">=</span> orders.user_id;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>RIGHT JOIN</strong> 连接用户表和订单表，显示所有订单及其用户（包括没有匹配用户的订单）。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> users.name, orders.item_name, orders.price </span><br><span class="line"><span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> users.id <span class="operator">=</span> orders.user_id;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>FULL JOIN</strong>（在 MySQL 中可以使用 UNION ALL 模拟 FULL JOIN）显示所有用户及其订单（包括没有匹配的用户或订单）。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> users.name, orders.item_name, orders.price </span><br><span class="line"><span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> users.id <span class="operator">=</span> orders.user_id</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> users.name, orders.item_name, orders.price </span><br><span class="line"><span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> users.id <span class="operator">=</span> orders.user_id</span><br><span class="line"><span class="keyword">WHERE</span> users.id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>GROUP BY 和 HAVING</strong> 查询每个用户的订单总金额，并筛选出总金额超过 200 的用户。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> users.name, <span class="built_in">SUM</span>(orders.price) <span class="keyword">AS</span> total_spent </span><br><span class="line"><span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> users.id <span class="operator">=</span> orders.user_id </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> users.name </span><br><span class="line"><span class="keyword">HAVING</span> total_spent <span class="operator">&gt;</span> <span class="number">200</span>;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>ORDER BY</strong> 按用户姓名和订单价格排序。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> users.name, orders.item_name, orders.price </span><br><span class="line"><span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> users.id <span class="operator">=</span> orders.user_id </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> users.name, orders.price <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><strong>LIMIT</strong> 只显示前 5 个订单。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> users.name, orders.item_name, orders.price </span><br><span class="line"><span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> users.id <span class="operator">=</span> orders.user_id </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> orders.price <span class="keyword">DESC</span> </span><br><span class="line">LIMIT <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h3 id="三、锁的概念和示例"><a href="#三、锁的概念和示例" class="headerlink" title="三、锁的概念和示例"></a>三、锁的概念和示例</h3><h4 id="1-共享锁（SHARED-LOCK）"><a href="#1-共享锁（SHARED-LOCK）" class="headerlink" title="1.共享锁（SHARED LOCK）"></a>1.共享锁（SHARED LOCK）</h4><p>允许多个事务同时读取数据，但不能进行修改。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WITH</span> (HOLDLOCK);</span><br></pre></td></tr></table></figure>

<p><strong>共享锁示例</strong></p>
<p>假设有两个事务T1和T2，都想读取同一行数据：</p>
<ul>
<li>T1获取共享锁，读取数据。</li>
<li>T2获取共享锁，读取数据。</li>
</ul>
<p>在这种情况下，两个事务可以同时读取数据，但在它们持有共享锁期间，其他事务不能对数据进行修改。</p>
<h4 id="2-排他锁（EXCLUSIVE-LOCK）"><a href="#2-排他锁（EXCLUSIVE-LOCK）" class="headerlink" title="2.排他锁（EXCLUSIVE LOCK）"></a>2.排他锁（EXCLUSIVE LOCK）</h4><p>允许事务读取和修改数据，当持有独占锁时，其他事务无法读取锁住的数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> orders <span class="keyword">SET</span> price <span class="operator">=</span> <span class="number">99.0</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>排他锁示例</strong></p>
<ul>
<li><p>T1获取排他锁，读取并修改数据。</p>
</li>
<li><p>T2尝试获取排他锁，但必须等待T1释放锁后才能继续。</p>
</li>
</ul>
<p>在这种情况下，只有一个事务可以同时对数据进行修改，防止并发修改导致的数据不一致问题。</p>
<h4 id="3-更新锁（UPDATE-LOCK）"><a href="#3-更新锁（UPDATE-LOCK）" class="headerlink" title="3.更新锁（UPDATE LOCK）"></a>3.更新锁（UPDATE LOCK）</h4><p>用于处理事务先读取数据后进行更新操作，防止死锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p><strong>更新锁示例</strong></p>
<p>假设有事务T1和T2都要读取并修改同一行数据，流程如下：</p>
<ol>
<li><strong>T1获取更新锁</strong>：<ul>
<li>T1: 获取更新锁，读取数据。</li>
<li>T2: 尝试获取更新锁，被阻塞；可以获取共享锁，读取数据。</li>
</ul>
</li>
<li><strong>T1准备修改数据</strong>：<ul>
<li>T1: 将更新锁升级为独占锁，进行数据修改。</li>
<li>T2: 仍然阻塞，等待T1释放锁。</li>
</ul>
</li>
<li><strong>T1完成修改并释放锁</strong>：<ul>
<li>T1: 完成修改，释放独占锁。</li>
<li>T2: 获取更新锁，读取数据，并准备修改。</li>
</ul>
</li>
</ol>
<h4 id="4-行级锁（Row-Level-Lock）"><a href="#4-行级锁（Row-Level-Lock）" class="headerlink" title="4.行级锁（Row-Level Lock）"></a>4.行级锁（Row-Level Lock）</h4><p>行级锁用于锁定特定行，在执行更新操作时常用。这样可以避免其他事务同时修改同一行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 锁定特定行</span></span><br><span class="line"><span class="keyword">UPDATE</span> orders <span class="keyword">SET</span> price <span class="operator">=</span> <span class="number">99.99</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> user_id <span class="operator">=</span> <span class="number">1</span> LOCK <span class="keyword">IN</span> SHARE MODE;</span><br></pre></td></tr></table></figure>

<h4 id="5-页级锁（Page-Level-Lock）"><a href="#5-页级锁（Page-Level-Lock）" class="headerlink" title="5.页级锁（Page-Level Lock）"></a>5.页级锁（Page-Level Lock）</h4><p>页级锁用于锁定包含多行数据的页，这种锁在某些情况下可以提高性能，但可能会导致锁争用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- MySQL 不支持直接的页级锁，下面的例子是逻辑上的演示</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> id <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="number">10</span> LOCK <span class="keyword">IN</span> SHARE MODE;</span><br></pre></td></tr></table></figure>

<h4 id="6-表级锁（Table-Level-Lock）"><a href="#6-表级锁（Table-Level-Lock）" class="headerlink" title="6.表级锁（Table-Level Lock）"></a>6.表级锁（Table-Level Lock）</h4><p>表级锁用于锁定整个表，当需要对整个表进行操作时使用。例如，进行批量更新时。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 锁定整个表以防止其他事务访问</span></span><br><span class="line">LOCK TABLES orders WRITE;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行批量更新</span></span><br><span class="line"><span class="keyword">UPDATE</span> orders <span class="keyword">SET</span> price <span class="operator">=</span> price <span class="operator">*</span> <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 释放表锁</span></span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure>

<h4 id="7-意向锁（Intention-Lock）"><a href="#7-意向锁（Intention-Lock）" class="headerlink" title="7.意向锁（Intention Lock）"></a>7.意向锁（Intention Lock）</h4><p>意向锁用于在多级锁定中标记意图，避免锁冲突。常见的意向锁有意向共享锁（IS）和意向排他锁（IX）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- MySQL 自动处理意向锁，无需手动设置</span></span><br><span class="line"><span class="comment">-- 以下为逻辑示例，展示意向锁的工作原理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务 1 获取意向排他锁（IX）</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务 2 获取意向共享锁（IS）</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">2</span> LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务 1 和事务 2 可以同时执行，因为意向锁不冲突</span></span><br></pre></td></tr></table></figure>

<h4 id="8-自定义锁（User-Defined-Lock）"><a href="#8-自定义锁（User-Defined-Lock）" class="headerlink" title="8.自定义锁（User-Defined Lock）"></a>8.自定义锁（User-Defined Lock）</h4><p>MySQL 提供 <code>GET_LOCK</code> 和 <code>RELEASE_LOCK</code> 函数，用于实现自定义锁。这对于需要在应用层实现复杂锁定逻辑时很有用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 获取自定义锁</span></span><br><span class="line"><span class="keyword">SELECT</span> GET_LOCK(<span class="string">&#x27;my_lock&#x27;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行操作</span></span><br><span class="line"><span class="keyword">UPDATE</span> orders <span class="keyword">SET</span> price <span class="operator">=</span> <span class="number">99.99</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 释放自定义锁</span></span><br><span class="line"><span class="keyword">SELECT</span> RELEASE_LOCK(<span class="string">&#x27;my_lock&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>MySQL的事务机制提供了一种确保数据库操作的可靠性和一致性的方法。事务是一组原子操作，要么全部成功，要么全部失败。MySQL支持事务的存储引擎主要是InnoDB。以下是关于MySQL事务的详细介绍。</p>
<h3 id="四、事务的四大特性（ACID）"><a href="#四、事务的四大特性（ACID）" class="headerlink" title="四、事务的四大特性（ACID）"></a>四、事务的四大特性（ACID）</h3><ol>
<li><strong>原子性（Atomicity）</strong>：事务中的所有操作要么全部完成，要么全部不完成。任何一个操作失败都会导致整个事务的失败，已执行的操作会被回滚到初始状态。</li>
<li><strong>一致性（Consistency）</strong>：事务执行前后，数据库的状态必须保持一致。数据从一种一致状态变为另一种一致状态。</li>
<li><strong>隔离性（Isolation）</strong>：一个事务的执行不能被其他事务干扰。不同事务之间的操作是相互隔离的。</li>
<li><strong>持久性（Durability）</strong>：一旦事务提交，其结果就永久保存，即使数据库发生故障。</li>
</ol>
<h4 id="事务的基本操作"><a href="#事务的基本操作" class="headerlink" title="事务的基本操作"></a>事务的基本操作</h4><p>在MySQL中，可以通过以下SQL命令来管理事务：</p>
<ul>
<li><code>START TRANSACTION</code>：开始一个新的事务。</li>
<li><code>COMMIT</code>：提交事务，保存所有更改。</li>
<li><code>ROLLBACK</code>：回滚事务，撤销所有更改。</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>以下是一个简单的事务操作示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开始事务</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行一些数据库操作</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> accounts (account_id, balance) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>如果在执行过程中发生错误，可以使用 <code>ROLLBACK</code> 撤销更改：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开始事务</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行一些数据库操作</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> accounts (account_id, balance) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果发生错误，回滚事务</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>

<h3 id="五、索引"><a href="#五、索引" class="headerlink" title="五、索引"></a>五、索引</h3><p>MySQL中的索引是用于提高查询速度的数据结构。索引类似于书籍的目录，通过索引可以快速定位数据，而不需要扫描整个表。下面是关于MySQL中索引的详细介绍：</p>
<h4 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h4><ol>
<li><p><strong>主键索引（Primary Key Index）</strong>：</p>
<ul>
<li>每个表只能有一个主键索引。</li>
<li>主键索引是一种唯一索引，不允许重复和NULL值。</li>
<li>创建主键时，数据库会自动创建主键索引。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>唯一索引（Unique Index）</strong>：</p>
<ul>
<li>唯一索引不允许两行具有相同的索引值。</li>
<li>一个表可以有多个唯一索引。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX idx_email <span class="keyword">ON</span> users (email);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>普通索引（Index）</strong>：</p>
<ul>
<li>普通索引允许重复和NULL值。</li>
<li>用于加速数据查询，但不会强制唯一性。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> users (name);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>全文索引（Fulltext Index）</strong>：</p>
<ul>
<li>用于全文搜索，适用于较大的文本字段。</li>
<li>主要用于<code>CHAR</code>、<code>VARCHAR</code>和<code>TEXT</code>类型的列。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> FULLTEXT INDEX idx_content <span class="keyword">ON</span> articles (content);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>组合索引（Composite Index）</strong>：</p>
<ul>
<li>由多个列组合而成的索引，用于多列的查询优化。</li>
<li>可以部分匹配列，提高查询效率。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name_email <span class="keyword">ON</span> users (name, email);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="索引的创建与删除"><a href="#索引的创建与删除" class="headerlink" title="索引的创建与删除"></a>索引的创建与删除</h4><p><strong>创建索引</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建普通索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> users (name);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建唯一索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX idx_email <span class="keyword">ON</span> users (email);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建全文索引</span></span><br><span class="line"><span class="keyword">CREATE</span> FULLTEXT INDEX idx_content <span class="keyword">ON</span> articles (content);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建组合索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_name_email <span class="keyword">ON</span> users (name, email);</span><br></pre></td></tr></table></figure>

<p><strong>删除索引</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除索引</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_name <span class="keyword">ON</span> users;</span><br></pre></td></tr></table></figure>

<p><strong>在创建表时定义索引</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    content TEXT,</span><br><span class="line">    FULLTEXT (content),</span><br><span class="line">    <span class="keyword">UNIQUE</span> (email),</span><br><span class="line">    INDEX idx_name_email (name, email)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/GXKJDX/blog/2024/07/31/MySQL%20%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9/" data-id="cm2ahnlme000mp0u43qvn6v5j" data-title="一、常用的 MySQL 命令示例" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Mabatis-Plus常见用法-Mapper层自定义SQL和分页器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/2024/07/28/Mabatis-Plus%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95-Mapper%E5%B1%82%E8%87%AA%E5%AE%9A%E4%B9%89SQL%E5%92%8C%E5%88%86%E9%A1%B5%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2024-07-28T14:32:50.000Z" itemprop="datePublished">2024-07-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/blog/2024/07/28/Mabatis-Plus%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95-Mapper%E5%B1%82%E8%87%AA%E5%AE%9A%E4%B9%89SQL%E5%92%8C%E5%88%86%E9%A1%B5%E5%99%A8/">四、Mybatis-Plus常见用法-Mapper层自定义SQL</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="Mapper层自定义SQL"><a href="#Mapper层自定义SQL" class="headerlink" title="Mapper层自定义SQL"></a>Mapper层自定义SQL</h3><p>在 MyBatis-Plus 中，可以通过注解和 XML 配置文件两种方式编写自定义 SQL。以下是两种方式的详细说明和示例。</p>
<h4 id="使用注解编写自定义-SQL"><a href="#使用注解编写自定义-SQL" class="headerlink" title="使用注解编写自定义 SQL"></a>使用注解编写自定义 SQL</h4><p>通过注解在 Mapper 接口中直接编写 SQL 语句。</p>
<h5 id="使用-Select-注解"><a href="#使用-Select-注解" class="headerlink" title="使用 @Select 注解"></a>使用 <code>@Select</code> 注解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM user WHERE status = #&#123;status&#125;&quot;)</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">selectUsersByStatus</span><span class="params">(<span class="meta">@Param(&quot;status&quot;)</span> <span class="type">int</span> status)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用-Insert-注解"><a href="#使用-Insert-注解" class="headerlink" title="使用 @Insert 注解"></a>使用 <code>@Insert</code> 注解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="meta">@Insert(&quot;INSERT INTO user(name, age, email) VALUES(#&#123;name&#125;, #&#123;age&#125;, #&#123;email&#125;)&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insertUser</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;age&quot;)</span> <span class="type">int</span> age, <span class="meta">@Param(&quot;email&quot;)</span> String email)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用-Update-注解"><a href="#使用-Update-注解" class="headerlink" title="使用 @Update 注解"></a>使用 <code>@Update</code> 注解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="meta">@Update(&quot;UPDATE user SET name = #&#123;name&#125; WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateUserName</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id, <span class="meta">@Param(&quot;name&quot;)</span> String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用-Delete-注解"><a href="#使用-Delete-注解" class="headerlink" title="使用 @Delete 注解"></a>使用 <code>@Delete</code> 注解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="meta">@Delete(&quot;DELETE FROM user WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteUserById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-XML-配置文件编写自定义-SQL"><a href="#使用-XML-配置文件编写自定义-SQL" class="headerlink" title="使用 XML 配置文件编写自定义 SQL"></a>使用 XML 配置文件编写自定义 SQL</h4><p>在 <code>resources/mapper</code> 目录下创建一个 <code>UserMapper.xml</code> 文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsersByStatus&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.entity.User&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM user WHERE status = #&#123;status&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">        INSERT INTO user(name, age, email) VALUES(#&#123;name&#125;, #&#123;age&#125;, #&#123;email&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUserName&quot;</span>&gt;</span></span><br><span class="line">        UPDATE user SET name = #&#123;name&#125; WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUserById&quot;</span>&gt;</span></span><br><span class="line">        DELETE FROM user WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 Mapper 接口中引用这些方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">selectUsersByStatus</span><span class="params">(<span class="meta">@Param(&quot;status&quot;)</span> <span class="type">int</span> status)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">insertUser</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;age&quot;)</span> <span class="type">int</span> age, <span class="meta">@Param(&quot;email&quot;)</span> String email)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateUserName</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id, <span class="meta">@Param(&quot;name&quot;)</span> String name)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteUserById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分页器"><a href="#分页器" class="headerlink" title="分页器"></a>分页器</h3><h4 id="配置分页插件"><a href="#配置分页插件" class="headerlink" title="配置分页插件"></a>配置分页插件</h4><p>创建一个配置类来配置分页插件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PaginationInterceptor <span class="title function_">paginationInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PaginationInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分页查询示例"><a href="#分页查询示例" class="headerlink" title="分页查询示例"></a>分页查询示例</h3><p>假设我们有一个用户表 <code>user</code>，我们需要对用户数据进行分页查询。以下是具体实现步骤。</p>
<h4 id="定义实体类"><a href="#定义实体类" class="headerlink" title="定义实体类"></a>定义实体类</h4><p>定义一个用户实体类 <code>User</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定义-Mapper-接口"><a href="#定义-Mapper-接口" class="headerlink" title="定义 Mapper 接口"></a>定义 Mapper 接口</h4><p>在 Mapper 接口中继承 <code>BaseMapper</code>，MyBatis-Plus 会自动生成常用的 CRUD 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Service-层实现分页查询"><a href="#Service-层实现分页查询" class="headerlink" title="Service 层实现分页查询"></a>Service 层实现分页查询</h4><p>在 Service 层中实现分页查询逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IPage&lt;User&gt; <span class="title function_">getUsersPage</span><span class="params">(<span class="type">int</span> currentPage, <span class="type">int</span> pageSize)</span> &#123;</span><br><span class="line">        Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(currentPage, pageSize);</span><br><span class="line">        <span class="keyword">return</span> userMapper.selectPage(page, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Controller-层调用分页查询"><a href="#Controller-层调用分页查询" class="headerlink" title="Controller 层调用分页查询"></a>Controller 层调用分页查询</h4><p>在 Controller 层中调用分页查询：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/page&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> IPage&lt;User&gt; <span class="title function_">getUsersPage</span><span class="params">(<span class="meta">@RequestParam</span> <span class="type">int</span> currentPage, <span class="meta">@RequestParam</span> <span class="type">int</span> pageSize)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUsersPage(currentPage, pageSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分页查询示例说明"><a href="#分页查询示例说明" class="headerlink" title="分页查询示例说明"></a>分页查询示例说明</h3><ol>
<li><strong>配置分页插件</strong>： 在 <code>MybatisPlusConfig</code> 类中，通过 <code>PaginationInterceptor</code> 配置分页插件，使其在项目中生效。</li>
<li><strong>定义实体类</strong>： 在 <code>User</code> 类中使用 <code>@TableName</code> 注解指定数据库表名，使用 <code>@TableId</code> 注解指定主键。</li>
<li><strong>定义 Mapper 接口</strong>： 在 <code>UserMapper</code> 接口中继承 <code>BaseMapper&lt;User&gt;</code>，使 MyBatis-Plus 提供的 CRUD 方法可用。</li>
<li><strong>Service 层实现分页查询</strong>： 在 <code>UserService</code> 类中，使用 <code>Page&lt;User&gt;</code> 对象封装分页参数，通过 <code>userMapper.selectPage(page, null)</code> 方法执行分页查询。</li>
<li><strong>Controller 层调用分页查询</strong>： 在 <code>UserController</code> 类中，通过 <code>UserService</code> 调用分页查询方法，并通过 RESTful API 返回分页结果。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/GXKJDX/blog/2024/07/28/Mabatis-Plus%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95-Mapper%E5%B1%82%E8%87%AA%E5%AE%9A%E4%B9%89SQL%E5%92%8C%E5%88%86%E9%A1%B5%E5%99%A8/" data-id="cm2ahnlme000jp0u41sqj3sz4" data-title="四、Mybatis-Plus常见用法-Mapper层自定义SQL" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/mybatisplus/" rel="tag">mybatisplus</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="page-number" href="/blog/page/3/">3</a><a class="extend next" rel="next" href="/blog/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/css/" rel="tag">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/mybatisplus/" rel="tag">mybatisplus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/nginx/" rel="tag">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/ubuntu/" rel="tag">ubuntu</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/Java/" style="font-size: 20px;">Java</a> <a href="/blog/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/blog/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/blog/tags/css/" style="font-size: 13.33px;">css</a> <a href="/blog/tags/docker/" style="font-size: 20px;">docker</a> <a href="/blog/tags/mybatisplus/" style="font-size: 20px;">mybatisplus</a> <a href="/blog/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/blog/tags/nginx/" style="font-size: 16.67px;">nginx</a> <a href="/blog/tags/ubuntu/" style="font-size: 16.67px;">ubuntu</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2025/04/">April 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2024/01/">January 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2025/04/11/JavaScript-%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/blog/2025/04/11/Java%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88/">五、Java基础-集合</a>
          </li>
        
          <li>
            <a href="/blog/2024/10/15/JavaScript-js%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/">一、JavaScript-数组</a>
          </li>
        
          <li>
            <a href="/blog/2024/08/27/Java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E8%AF%95%E9%A2%9840-46/">四、Java基础-面试题40-46</a>
          </li>
        
          <li>
            <a href="/blog/2024/08/27/SpringBoot-Java%20Bean%20Validation%20%E6%B3%A8%E8%A7%A3/">一、SpringBoot Java Bean Validation 注解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/blog/js/jquery-3.6.4.min.js"></script>



  
<script src="/blog/fancybox/jquery.fancybox.min.js"></script>




<script src="/blog/js/script.js"></script>





  </div>
</body>
</html>