<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>一、Java基础-面试题1-13 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="1 Java和C++的区别？C++是编译型语言，Java是解释型语言。 2 如何理解面向过程和面向对象？2.1面向过程把问题分解成每一步骤，每一个步骤用函数实现，面向对象把步骤分解，步骤抽象，形成对象，通过对象的调用解决问题。 2.2面向对象的三大特点  封装：抽象成一个具体的Java类  继承：子类继承父类（基类）的方法，方便方法复用  多态：override运行时多态 overload编译时多">
<meta property="og:type" content="article">
<meta property="og:title" content="一、Java基础-面试题1-13">
<meta property="og:url" content="https://github.com/GXKJDX/blog/2024/08/24/Java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E8%AF%95%E9%A2%981-13/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1 Java和C++的区别？C++是编译型语言，Java是解释型语言。 2 如何理解面向过程和面向对象？2.1面向过程把问题分解成每一步骤，每一个步骤用函数实现，面向对象把步骤分解，步骤抽象，形成对象，通过对象的调用解决问题。 2.2面向对象的三大特点  封装：抽象成一个具体的Java类  继承：子类继承父类（基类）的方法，方便方法复用  多态：override运行时多态 overload编译时多">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://qinyunjian-1316017204.cos.ap-guangzhou.myqcloud.com/images/typora/1693569145559-1464948e-b069-4234-8f03-40dba93f044b.jpeg">
<meta property="article:published_time" content="2024-08-24T14:32:50.000Z">
<meta property="article:modified_time" content="2024-10-15T13:34:58.201Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://qinyunjian-1316017204.cos.ap-guangzhou.myqcloud.com/images/typora/1693569145559-1464948e-b069-4234-8f03-40dba93f044b.jpeg">
  
    <link rel="alternate" href="/blog/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/blog/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/blog/css/style.css">

  
    
<link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/blog/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/GXKJDX/blog"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Java基础-面试题1-13" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/2024/08/24/Java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E8%AF%95%E9%A2%981-13/" class="article-date">
  <time class="dt-published" datetime="2024-08-24T14:32:50.000Z" itemprop="datePublished">2024-08-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      一、Java基础-面试题1-13
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h5 id="1-Java和C-的区别？"><a href="#1-Java和C-的区别？" class="headerlink" title="1 Java和C++的区别？"></a>1 Java和C++的区别？</h5><p>C++是编译型语言，Java是解释型语言。</p>
<h5 id="2-如何理解面向过程和面向对象？"><a href="#2-如何理解面向过程和面向对象？" class="headerlink" title="2 如何理解面向过程和面向对象？"></a>2 如何理解面向过程和面向对象？</h5><p>2.1面向过程把问题分解成每一步骤，每一个步骤用函数实现，面向对象把步骤分解，步骤抽象，形成对象，通过对象的调用解决问题。</p>
<p>2.2面向对象的三大特点</p>
<ul>
<li><p><strong>封装</strong>：抽象成一个具体的Java类</p>
</li>
<li><p><strong>继承</strong>：子类继承父类（基类）的方法，方便方法复用</p>
</li>
<li><p><strong>多态</strong>：<code>override</code>运行时多态 <code>overload</code>编译时多态</p>
</li>
</ul>
<h5 id="3接口和抽象类的区别？"><a href="#3接口和抽象类的区别？" class="headerlink" title="3接口和抽象类的区别？"></a>3接口和抽象类的区别？</h5><ul>
<li><p>抽象类可以有构造器，接口不能有构造器，抽象类和接口都不能被实例化。</p>
</li>
<li><p>接口可以被实现，抽象类可以被继承。</p>
</li>
<li><p>一个类可以实现多个接口，但是只能继承一个抽象类，接口支持多重继承。</p>
</li>
</ul>
<p>抽象类示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AnimalTwo</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法，子类必须实现</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AnimalTwo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am father&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 抽象类中的具体方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">breathe</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Breathing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DogTwo</span> <span class="keyword">extends</span> <span class="title class_">AnimalTwo</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bark!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DogTwo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;I am son&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        AnimalTwo animalTwo = new AnimalTwo(); 抽象类不能被实例化</span></span><br><span class="line">        <span class="type">DogTwo</span> <span class="variable">dogTwo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DogTwo</span>();</span><br><span class="line">        dogTwo.makeSound();  <span class="comment">// 输出：Bark!</span></span><br><span class="line">        dogTwo.breathe();    <span class="comment">// 输出：Breathing...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能这样做：</span></span><br><span class="line"><span class="comment">// Flyable flyable = new Flyable(); // 编译错误，因为接口不能被实例化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样是可以的：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bird is flying&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Flyable</span> <span class="variable">flyable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>(); <span class="comment">// 使用实现了接口的类来实例化</span></span><br><span class="line">        flyable.fly(); <span class="comment">// 输出：Bird is flying</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-Java中已经有了基本数据类型，为什么还需要包装类？"><a href="#4-Java中已经有了基本数据类型，为什么还需要包装类？" class="headerlink" title="4 Java中已经有了基本数据类型，为什么还需要包装类？"></a>4 Java中已经有了基本数据类型，为什么还需要包装类？</h5><p>4.1区别：</p>
<ul>
<li>基本类型默认值为0，false或\u0000等，包装类为null。</li>
<li>基本直接使用，不需要new，包装需要new。</li>
</ul>
<p>4.2自动拆箱和装箱</p>
<ul>
<li>自动拆箱：包装类转成基本数据类型；自动装箱：基本数据类型转换成包装类。</li>
</ul>
<p>4.3自动拆箱和装箱应用场景：包装类型和基本类型比较大小，包装类型的运算等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoBoxingUnboxingExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在 c == d 的比较中，c 和 d 是 Integer 对象，因此它们的引用地址不同，因为它们的值超过了 Java 的整数缓存范围（-128 到 127）。</span></span><br><span class="line"><span class="comment">        如果 c 和 d 在这个范围内，== 比较结果为 true，因为 Java 对这些值进行了缓存。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基本类型</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 包装类型</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较基本类型和包装类型</span></span><br><span class="line">        <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;a 和 b 相等 (自动拆箱)&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;a 和 b 不相等&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较两个包装类型</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c == d) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;c 和 d 引用相同&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;c 和 d 引用不同&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 equals() 方法比较两个包装类型的值</span></span><br><span class="line">        <span class="keyword">if</span> (c.equals(d)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;c 和 d 的值相等&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;c 和 d 的值不相等&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基本类型和包装类型的运算</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> a + b; <span class="comment">// b 自动拆箱为 int 类型</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a + b = &quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-为什么不能用float-double表示金额？"><a href="#5-为什么不能用float-double表示金额？" class="headerlink" title="5 为什么不能用float,double表示金额？"></a>5 为什么不能用float,double表示金额？</h5><p>避免造成精度丢失，<code>Java</code>提供了<code>BigDecimal</code>来进行精确计算。</p>
<h5 id="6-为什么不能用BigDecimal中的equals方法来做值比较？"><a href="#6-为什么不能用BigDecimal中的equals方法来做值比较？" class="headerlink" title="6 为什么不能用BigDecimal中的equals方法来做值比较？"></a>6 为什么不能用BigDecimal中的equals方法来做值比较？</h5><p>因为使用<code>BigDecimal</code>中的<code>equals</code>方法会比较值和标度，如比较0.1和0.10，他们的值虽然是一样的，但是精度是不一样的。通常使用<code>compareTo</code>进行值的比较。</p>
<h5 id="7-BigDecimal-double-和BigDecimal-String-有什么区别？"><a href="#7-BigDecimal-double-和BigDecimal-String-有什么区别？" class="headerlink" title="7 BigDecimal(double)和BigDecimal(String)有什么区别？"></a>7 BigDecimal(double)和BigDecimal(String)有什么区别？</h5><p><code>BigDecimal(double)</code>创建出的值并不是准确的数字，而是一个近似值，而使用<code>BigDecimal(String)</code>所创建出的值就等于其本身。</p>
<p>如：<code>new BigDecimal(0.1)</code>所创建出的值并不等于0.1，而<code>BigDecimal(&quot;0.1&quot;)</code>创建出的值正好等于0.1。</p>
<h5 id="8-String、StringBuilder、StringBuffer的区别？"><a href="#8-String、StringBuilder、StringBuffer的区别？" class="headerlink" title="8 String、StringBuilder、StringBuffer的区别？"></a>8 String、StringBuilder、StringBuffer的区别？</h5><p>8.1 <code>String</code>类被声明为<code>final</code>，<code>final</code>修饰的类是不能被继承的，所以<code>String</code>类中的方法无法被重写。</p>
<p>8.2 <code> String</code>类没有提供用于修改字符串内容的方法，任何对字符串的修改，都会产生一个新的<code>String</code>对象。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span></span><br><span class="line">s = s.concat(<span class="string">&quot;ef&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>虽然字符串内容看似已经成功修改，但是实际上s已经创建了一个新的对象了。</p>
<p><img src="https://qinyunjian-1316017204.cos.ap-guangzhou.myqcloud.com/images/typora/1693569145559-1464948e-b069-4234-8f03-40dba93f044b.jpeg"></p>
<p>所以当需要创建可变的字符串对象时，通常使用<code>StringBuilder</code>或<code>StringBuffer</code>。</p>
<p>8.3 String的”+”是如何实现的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1 + <span class="string">&quot;,&quot;</span> + s2 <span class="comment">//等同于(new StringBuilder()).append(s1).append(&quot;,&quot;).append(s2).toString()</span></span><br></pre></td></tr></table></figure>

<p>使用<code>+</code>进行字符拼接，实际上是通过<code>StringBuilder</code>的<code>append</code>方法进行处理的。</p>
<p>8.4 为什么不要再循环中频繁的使用字符串拼接，而是使用<code>StringBuffer</code>和<code>StringBuilder</code>进行替代</p>
<p>因为每次循坏都会创建临时对象，造成性能下降和内存浪费，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    result += i;  <span class="comment">//等同于(new StringBuilder()).append(result).append(i).toString()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9-String为什么设计成不可变的？"><a href="#9-String为什么设计成不可变的？" class="headerlink" title="9 String为什么设计成不可变的？"></a>9 String为什么设计成不可变的？</h5><p>可以从缓存，安全性，线程安全等角度进行解释。</p>
<p>9.1 <strong>缓存</strong>：<code>Java</code>中会存在一个字符串常量池，当创建对象时，常量池会先检查是否已经存在改对象，如已经存在则指向同一对象，如不存在则创建新的对象，这种机制依赖于<code>String</code>的不可变性。</p>
<p>9.2 <strong>安全性</strong>：在实际应用中，用户密钥，文件路径等敏感信息都是用<code>String</code>类来进行存储的，如果<code>String</code>类是可变的，在某些情况下内容会被恶意篡改，从而引发安全性问题。</p>
<p>9.3 <strong>线程安全</strong>：不可变对象在多个线程之间共享，它们的线程是安全的，当某个线程更改了值，会在字符串常量池中创建一个新的字符串，而不是修改相同的值，因此，字符串对于多线程来说是安全的。</p>
<h5 id="10-String-str-new-String-hollis-创建了几个对象？"><a href="#10-String-str-new-String-hollis-创建了几个对象？" class="headerlink" title="10 String str&#x3D;new String(hollis)创建了几个对象？"></a>10 String str&#x3D;new String(hollis)创建了几个对象？</h5><p>通常情况下，这行代码会创建两个对象，</p>
<ol>
<li><strong>字符串常量池中的对象</strong>：<ul>
<li><code>hollis</code> 是一个字符串字面量。在代码执行时，Java 会检查字符串常量池中是否已经存在内容为 <code>hollis</code> 的字符串对象。如果不存在，Java 会在字符串常量池中创建一个新的 <code>hollis</code> 字符串对象。</li>
<li>如果常量池中已经存在 <code>hollis</code>，则不会创建新的对象。</li>
</ul>
</li>
<li><strong>堆中的 <code>String</code> 对象</strong>：<ul>
<li><code>new String(hollis)</code> 明确表示创建一个新的 <code>String</code> 对象，即使 <code>hollis</code> 已经存在于字符串常量池中。这个新的 <code>String</code> 对象会存储在堆（heap）中，并且它的内容会是指向常量池中 <code>hollis</code> 的引用。</li>
<li>这个 <code>String</code> 对象是通过 <code>new</code> 关键字创建的，因此在每次执行这行代码时都会生成一个新的对象。</li>
</ul>
</li>
</ol>
<p><strong>结论</strong>：</p>
<ul>
<li>如果 <code>hollis</code> 字符串字面量在常量池中不存在，那么 <code>String str = new String(hollis);</code> 这行代码会创建两个对象：一个在字符串常量池中，一个在堆中。</li>
<li>如果 <code>hollis</code> 字符串字面量已经在常量池中存在，那么这行代码只会创建一个对象，即堆中的 <code>String</code> 对象。</li>
</ul>
<p>总结： <strong>通常情况下，这行代码会创建两个对象</strong>，一个在常量池中（如果字面量 <code>hollis</code> 还不存在），一个在堆中（无论如何都会创建）。</p>
<h5 id="11-String-a-“ab”-String-b-“a”-“b”-a-b-吗？"><a href="#11-String-a-“ab”-String-b-“a”-“b”-a-b-吗？" class="headerlink" title="11 String a &#x3D; “ab”; String b &#x3D; “a” + “b”; a &#x3D;&#x3D; b 吗？"></a>11 String a &#x3D; “ab”; String b &#x3D; “a” + “b”; a &#x3D;&#x3D; b 吗？</h5><p>结果为<code>true</code>，因为&#x3D;&#x3D;比较的是对象的引用，因为a和b都是<strong>字面量</strong>组成的字符串，引用地址在编译的时候已经确定了，在编译时，会把字面量直接拼接在一起，所以二者都是引用同一个对象。</p>
<p><strong>字面量</strong>：说简单点，字面量就是指有数字、字母等构成的字符串或数值，字面量只能以右值出现，即右值等于左边的值，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hollis&quot;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="12-RPC接口返回中，使用基本类型还是包装类？"><a href="#12-RPC接口返回中，使用基本类型还是包装类？" class="headerlink" title="12 RPC接口返回中，使用基本类型还是包装类？"></a>12 RPC接口返回中，使用基本类型还是包装类？</h5><p>尽量使用包装类，因为基本数据类型在发生异常的时候可能会返回默认值，如<code>int</code> 默认返回0，而包装类则会返回<code>null</code>。</p>
<h5 id="13-在开发过程中常见的语法糖？"><a href="#13-在开发过程中常见的语法糖？" class="headerlink" title="13 在开发过程中常见的语法糖？"></a>13 在开发过程中常见的语法糖？</h5><p>所谓语法糖就是方便开发人员使用，对语法进行简化；但在编译的时候会还原成最基础的语法，这个就是解语法糖。</p>
<p>13.1 <strong><code>switch</code>支持使用<code>String</code>类</strong></p>
<p><code>Java</code>中的<code>switch</code>原本就是支持基本类型，比如<code>int</code>、<code>char</code>等，对于<code>int</code>类型，会直接比较数值，对于<code>char</code>，则会比较ASCII码。对于编译器来说，</p>
<p>任何类型的比较都要转成整型。如<code>short</code>、<code>char</code>（ASCII码是整型）、以及<code>int</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (str) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;world&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际在编译器中的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span><span class="string">&quot;world&quot;</span>;</span><br><span class="line">String s;</span><br><span class="line"><span class="keyword">switch</span>((s=str).hashcode()) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">99162322</span>:</span><br><span class="line">		<span class="keyword">if</span>(s.equals(<span class="string">&quot;hello”))</span></span><br><span class="line"><span class="string">			System.out.println(&quot;</span>hello<span class="string">&quot;);</span></span><br><span class="line"><span class="string">		break;</span></span><br><span class="line"><span class="string">	case 113318802:</span></span><br><span class="line"><span class="string">		if(s.equals(&quot;</span>world<span class="string">&quot;))</span></span><br><span class="line"><span class="string">			System.out.println(&quot;</span>world<span class="string">&quot;);</span></span><br><span class="line"><span class="string">		break;</span></span><br><span class="line"><span class="string">	default:</span></span><br><span class="line"><span class="string">		break;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>字符串的<code>switch</code>是通过<code>equals()</code>和<code>hasdCode()</code>方法来实现的</p>
<p>13.2 <strong>泛型</strong></p>
<p>13.2.1 <strong>定义</strong>：泛型允许类、接口、和方法在定义的时候使用类型参数，这能使代码更加通用和类型安全。</p>
<p><strong>类</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T item;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setItem</span><span class="params">(T item)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getItem</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，<code>Box</code> 类是一个泛型类，<code>T</code> 是一个类型参数，可以在创建 <code>Box</code> 对象时指定具体的类型。</p>
<p><strong>接口</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceName</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 在接口中使用类型参数T</span></span><br><span class="line">    T <span class="title function_">Method</span><span class="params">(T param)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法</strong>：方法也可以是泛型的，即方法定义中可以有一个或多个类型参数。这使得方法能够处理不同类型的对象，而不需要定义多个重载方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(T[] array)</span> &#123; <span class="comment">// 方法声明使用了泛型类型（如 T）</span></span><br><span class="line">    <span class="keyword">for</span> (T element : array) &#123;</span><br><span class="line">        System.out.println(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果去掉方法中的<code>&lt;T&gt;</code>，则编译器会报警：Cannot resolve symbol ‘T’，这意味着编译器不知道<code>T</code>是什么类型。</p>
<p>13.2.2 <strong>泛型的边界</strong>：对泛型类型参数进行约束，比如要求类型参数必须是某个类的子类或实现某个接口。这可以通过使用 <code>extends</code> 关键字来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="keyword">void</span> <span class="title function_">printNumber</span><span class="params">(T number)</span> &#123;</span><br><span class="line">    System.out.println(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中，<code>T</code> 必须是 <code>Number</code> 的子类或 <code>Number</code> 本身。这样就限制了 <code>printNumber</code> 方法只能接受数字类型的参数</p>
<p>13.2.3 <strong>通配符</strong>：</p>
<p>在泛型中，通配符用于表示未知类型。常见的通配符有两种：</p>
<ul>
<li><strong>无界通配符（?）</strong>：可以接受任何类型。</li>
<li><strong>有界通配符</strong>：<ul>
<li>**<code>? extends T</code>**：表示可以接受 <code>T</code> 类型及其子类型。</li>
<li>**<code>? super T</code>**：表示可以接受 <code>T</code> 类型及其父类型。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processElements</span><span class="params">(List&lt;? extends Number&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Number number : list) &#123;</span><br><span class="line">        System.out.println(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中，<code>List&lt;? extends Number&gt;</code> 表示可以接受一个 <code>Number</code> 或 <code>Number</code> 的子类的列表。</p>
<p>13.2.4 <strong>类型擦除</strong></p>
<p>泛型在编译时被擦除，实际上运行时并不保留类型信息。例如，<code>List&lt;String&gt;</code> 在运行时就是 <code>List</code>。</p>
<p>13.3 <strong>自动拆箱与装箱</strong></p>
<p><strong>自动装箱</strong>：原始类型转换成对应的对象，如int变量转换成Integer对象。</p>
<p><strong>自动拆箱</strong>：对应的对象转成成原始类型，Integer对象转换成int类型值。</p>
<p>原始类型byte,short,char,int,long,float,double,boolean 对应的封装类为Byte,Short,Character,Integer,Long,Float,Double,Boolean。装箱过程是通过调用包装器的<code>valueOf</code>方法实现的，而拆箱过程则是调用包装器的<code>xxxValue</code>方法实现的，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">// 自动装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;       <span class="comment">// 自动拆箱</span></span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>);  <span class="comment">// 自动装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i.intValue();             <span class="comment">// 自动拆箱</span></span><br></pre></td></tr></table></figure>

<p>13.4 <strong>枚举</strong></p>
<p>枚举是一种特殊的数据类型，用于表示有限的一组常量。当我们使用<code>enum</code>来定义一个枚举类型的时候，编译器会自动帮我们创建一个<code>final</code>类型的类继承<code>enum</code>类，所以枚举类型不能被继承。</p>
<p>13.5 <strong>for-each</strong></p>
<p>for-each的实现原理其实就是使用了普通的for循环和迭代器，迭代器示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 ArrayList 并添加一些元素</span></span><br><span class="line">    ArrayList&lt;String&gt; fruits = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    fruits.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">    fruits.add(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">    fruits.add(<span class="string">&quot;Cherry&quot;</span>);</span><br><span class="line">    fruits.add(<span class="string">&quot;Date&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取该 ArrayList 的迭代器</span></span><br><span class="line">    Iterator&lt;String&gt; iterator = fruits.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用迭代器遍历集合</span></span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) <span class="comment">//检查集合是否存在下一元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fruit</span> <span class="operator">=</span> iterator.next();<span class="comment">//获取当前元素</span></span><br><span class="line">        System.out.println(fruit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>迭代器的特点</strong></p>
<ul>
<li><strong>顺序访问</strong>：<code>Iterator</code> 提供了一种顺序访问集合元素的方式。</li>
<li><strong>移除元素</strong>：<code>Iterator</code> 还提供了 <code>remove()</code> 方法，可以在遍历时移除当前元素，但需要注意，它只能在调用 <code>next()</code> 之后调用，且只能移除当前遍历的元素</li>
</ul>
<p>13.6 <strong>try-with-resource</strong></p>
<p>基本语法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">ResourceType</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceType</span>()) &#123;</span><br><span class="line">    <span class="comment">// 使用资源</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType e) &#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>ResourceType</strong>: 资源的类型，它必须实现 <code>AutoCloseable</code> 接口。</p>
</li>
<li><p><strong>resource</strong>: 声明并初始化要使用的资源。</p>
</li>
<li><p><strong>try 块</strong>: 在此块中使用资源，资源在此块结束时自动关闭。</p>
</li>
<li><p><strong>catch 块</strong>: 用于处理可能出现的异常。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/GXKJDX/blog/2024/08/24/Java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E8%AF%95%E9%A2%981-13/" data-id="cm2ahnlma0008p0u43xv8cap3" data-title="一、Java基础-面试题1-13" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2024/08/25/Java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E8%AF%95%E9%A2%9814-26/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          二、Java基础-面试题14-26
        
      </div>
    </a>
  
  
    <a href="/blog/2024/07/31/MySQL%20%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">一、常用的 MySQL 命令示例</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/css/" rel="tag">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/mybatisplus/" rel="tag">mybatisplus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/nginx/" rel="tag">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/ubuntu/" rel="tag">ubuntu</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/Java/" style="font-size: 20px;">Java</a> <a href="/blog/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/blog/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/blog/tags/css/" style="font-size: 13.33px;">css</a> <a href="/blog/tags/docker/" style="font-size: 20px;">docker</a> <a href="/blog/tags/mybatisplus/" style="font-size: 20px;">mybatisplus</a> <a href="/blog/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/blog/tags/nginx/" style="font-size: 16.67px;">nginx</a> <a href="/blog/tags/ubuntu/" style="font-size: 16.67px;">ubuntu</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2025/04/">April 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2024/01/">January 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2025/04/11/JavaScript-%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/blog/2025/04/11/Java%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88/">五、Java基础-集合</a>
          </li>
        
          <li>
            <a href="/blog/2024/10/15/JavaScript-js%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/">一、JavaScript-数组</a>
          </li>
        
          <li>
            <a href="/blog/2024/08/27/Java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E8%AF%95%E9%A2%9840-46/">四、Java基础-面试题40-46</a>
          </li>
        
          <li>
            <a href="/blog/2024/08/27/SpringBoot-Java%20Bean%20Validation%20%E6%B3%A8%E8%A7%A3/">一、SpringBoot Java Bean Validation 注解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/blog/js/jquery-3.6.4.min.js"></script>



  
<script src="/blog/fancybox/jquery.fancybox.min.js"></script>




<script src="/blog/js/script.js"></script>





  </div>
</body>
</html>